<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="人生，总有些黑暗的隧道需要自己穿越">
    <meta name="author" content="EmiyaQ">
    
    <title>
        
            设计模式 |
        
        The winter sunshine
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.svg">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"sangrealwar.github.io","root":"/","language":"zh-CN","path":"search.xml"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"The winter sunshine","author":"EmiyaQ","avatar":"/images/pig.png","logo":"/images/logo.svg","favicon":"/images/logo.svg"},"menu":{"home":"/","archives":"/archives","categories":"/categories"},"first_screen":{"enable":false,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"Keep writing and Keep loving.","hitokoto":false},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":false,"hide_header":true},"home":{"announcement":null,"category":true,"tag":true,"post_datetime":"updated"},"post":{"author_badge":{"enable":false,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":false,"min2read":false},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":false,"share":false,"reward":{"enable":false,"img_link":null,"text":null,"icon":null}},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":false,"site_uv":false,"site_pv":false,"page_pv":false}},"local_search":{"enable":true,"preload":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.36"},"waline":{"server_url":null,"reaction":false,"version":"3.2.1"},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":true},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":false},"footer":{"since":2020,"word_count":false,"site_deploy":{"enable":false,"provider":"github","url":null},"record":{"enable":false,"list":[{"code":null,"link":null}]}},"inject":{"enable":false,"css":[null],"js":[null]},"root":"","source_data":{},"version":"4.2.3"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left flex-start border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               The winter sunshine
            </a>
        </div>

        <div class="right border-box">
            <div class="pc border-box">
                <ul class="menu-list border-box">
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/">
                                
                                首页
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/archives">
                                
                                归档
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/categories">
                                
                                分类
                                
                            </a>
                            
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="menu-text-color fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile border-box flex-start">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list border-box">
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/">
                            
                            首页
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/archives">
                            
                            归档
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/categories">
                            
                            分类
                        </a>
                        
                    </label>
                    
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        设计模式
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/pig.png">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">EmiyaQ</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2025-01-12 10:42:38</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Sun Jan 12 2025 11:46:40 GMT+0800">2025-01-12 11:46:40</span>
            </span>
        

        

        

        
        
        
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body ">
                    

                    
                         <meta name="referrer" content="no-referrer"/>

<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p><img  
                       lazyload
                       alt="image"
                       data-src="/./5_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.png"
                       
                 ></p>
<h1 id="文字版"><a href="#文字版" class="headerlink" title="文字版"></a>文字版</h1><h2 class="topic">
<a name="78r9fk70sj5tk0fllgfjrsqodp">创建型</a>
</h2>
<h3 class="topic">
<a name="0nau92h7gdm942ms82c504995k">&nbsp;工厂模式</a>
</h3>
<h3 class="topic">
<a name="3ou1hu8ipmaajjvlpqnh9djovs">&nbsp;&nbsp;一般工厂：客户端传递需要生成的参数，由工厂类完成选择判断，生成具体的产品</a>
</h3>
<h3 class="topic">
<a name="147k605fl93td5ffoejcr5v1a8">&nbsp;&nbsp;工厂模式：转移了判断，将具体的工厂升级为抽象工厂，由客户端决定实例化哪个工厂，从而产生具体的产品</a>
</h3>
<h3 class="topic">
<a name="6q6bs51nkt6sc24sgjhq11e3go">&nbsp;&nbsp;目标：解耦分离，将产品构造的逻辑封装在工厂中，使得工厂产生的对象能够相互独立修改，提高扩展性</a>
</h3>
<h3 class="topic">
<a name="22aj9qsqsbe32giqaiu4tvdmct">&nbsp;&nbsp;对修改封闭（不需要修改工厂类）扩展开放（只需要继承工厂类）</a>
</h3>
<h3 class="topic">
<a name="6ghu7i5c9mjpg0hl73ku2ccqjv">&nbsp;抽象工厂</a>
</h3>
<h3 class="topic">
<a name="3qfk2rca623nuuvmtatn9i303v">&nbsp;&nbsp;通过工厂模式，实现了修改封闭和扩展开放，当有多条产品线时，抽象产品和工厂类之间就形成了抽象工厂</a>
</h3>
<h3 class="topic">
<a name="0m13g2tj648gc1v72qvnr7gct5">&nbsp;&nbsp;一般客户端需要负责选择具体的产品工厂，当需要更换产品线时，需要找到所有客户端，进行修改</a>
</h3>
<h3 class="topic">
<a name="3d9asm6f4biap9tnq30gcbaond">&nbsp;&nbsp;优化方式：通过引入简单工厂，将客户端选择工厂的逻辑用工厂方法进行封装，同时将选择逻辑用常量、反射、配置文件加载的方式处理，统一暴露抽象产品接口。这样客户端只知道抽象产品，而不需要考虑产品生成过程</a>
</h3>
<h3 class="topic">
<a name="536en8ngoeu27e74hggpifgb1r">&nbsp;建造者</a>
</h3>
<h3 class="topic">
<a name="6o8it1k6e36437nfiu1ccn9jht">&nbsp;&nbsp;将复杂的对象构建与表示分离，使得同样的的构建过程可以创建不同的表示</a>
</h3>
<h3 class="topic">
<a name="66fjb5q1rtkg2s9mkvbipqo679">&nbsp;&nbsp;Builder是抽象步骤，提取了构建过程中必备的步骤</a>
</h3>
<h3 class="topic">
<a name="3tjr28bbvuvol142tio0fjiodb">&nbsp;&nbsp;Director是指挥者，用来控制构建过程</a>
</h3>
<h3 class="topic">
<a name="58e3jtinl8650qdvbi8vs60tol">&nbsp;&nbsp;用于创建一些复杂对象，这些对象内部的构建顺序通常是稳定的</a>
</h3>
<h3 class="topic">
<a name="104tpru9p9sp02aolc41a74a8o">&nbsp;单例</a>
</h3>
<h3 class="topic">
<a name="118a65lc7vijrce35ibfd9sef0">&nbsp;&nbsp;懒汉式</a>
</h3>
<h3 class="topic">
<a name="7tba3tv4ft2q3hs4hffuaboipr">&nbsp;&nbsp;&nbsp;双重检查（变量由volatile修饰，获取实例时通过在加锁前后两次判断）</a>
</h3>
<h3 class="topic">
<a name="7e5nhl1jndca2rv4736vb4tbe4">&nbsp;&nbsp;饿汉式</a>
</h3>
<h3 class="topic">
<a name="77nc36fq9jtstmlup51kkrh3u0">&nbsp;&nbsp;&nbsp;静态初始化，在类加载的时候就加载静态变量，避免了加锁，提前分配内存</a>
</h3>
<h3 class="topic">
<a name="1o9fsvbu0s7j58j22u870d2g7o">&nbsp;原型</a>
</h3>
<h3 class="topic">
<a name="051pm0gb09cadgr6u43kfef517">&nbsp;&nbsp;就是对象clone</a>
</h3>
<h2 class="topic">
<a name="39nhlgpblu3kd0fcab49ghom92">结构型</a>
</h2>
<h3 class="topic">
<a name="68kc79c0qee0m97g5ldjnsqgbg">&nbsp;组合</a>
</h3>
<h3 class="topic">
<a name="4lgpfct03dg5jjibo0mr44upu1">&nbsp;&nbsp;将对象组合成树的形式，使用用户对单个对象和组合对象的使用有一致性</a>
</h3>
<h3 class="topic">
<a name="3pokjnugpd41ohontc009m89o1">&nbsp;&nbsp;透明模式，所有子对象实现的方法都相同</a>
</h3>
<h3 class="topic">
<a name="5og466evd46ag8prbhg92jbml0">&nbsp;&nbsp;安全方式，某些叶子节点不需要实现的add，remove等增加子对象的方法不作为接口</a>
</h3>
<h3 class="topic">
<a name="6pdl2sd20s1v0us3hsun9d4gl4">&nbsp;装饰</a>
</h3>
<h3 class="topic">
<a name="2naof0bf8lci8dojkglaq1qd15">&nbsp;&nbsp;动态给一个对象添加一些额外的职责</a>
</h3>
<h3 class="topic">
<a name="75711hnglajhi9607mg3pbg645">&nbsp;&nbsp;通过对象组合的方式，增加对象的功能特性</a>
</h3>
<h3 class="topic">
<a name="2l5k1v99kocvgismvudkre1s6t">&nbsp;&nbsp;需要装饰的对象/行为抽象名为Component</a>
</h3>
<h3 class="topic">
<a name="4j25lid46ibv8tmr5fli0gr6ao">&nbsp;&nbsp;装饰主体取名为Decorator，（简单理解为具体的装饰者）</a>
</h3>
<h3 class="topic">
<a name="1qb8cot37mmdjq9vutr863hfko">&nbsp;&nbsp;Component的各种实现都是不同装饰程度的装饰体</a>
</h3>
<h3 class="topic">
<a name="6g3fdoke4smhg4lbjbgcm1qu7j">&nbsp;外观</a>
</h3>
<h3 class="topic">
<a name="7etnverpvqhpd0hepnnr727mps">&nbsp;&nbsp;对内部子系统提供一个统一的对外一致性界面</a>
</h3>
<h3 class="topic">
<a name="6mq535j3aud534gs33aksgkpas">&nbsp;&nbsp;适用于兼容历史系统，减少两个系统的依赖</a>
</h3>
<h3 class="topic">
<a name="1j3j0o964dm6ohcdic8gqhr4s5">&nbsp;&nbsp;两个系统接口不同</a>
</h3>
<h3 class="topic">
<a name="4hladvhevlotot9eb5pp97krr1">&nbsp;适配器</a>
</h3>
<h3 class="topic">
<a name="67pgqa0s0tuf78e4gk83gr2r62">&nbsp;&nbsp;兼容子系统，并提供相同的接口</a>
</h3>
<h3 class="topic">
<a name="3fqrmpdehi2sd1rovqbb2ksndl">&nbsp;&nbsp;偏向于维护阶段使用</a>
</h3>
<h3 class="topic">
<a name="3tpb9jh42ur93d3umkt194bc2k">&nbsp;桥接</a>
</h3>
<h3 class="topic">
<a name="1lr0n8fr2eblep7d82amemsmin">&nbsp;&nbsp;由于继承关系用有更强的耦合，当实现方式有多个维度时，考虑合成/组合原则，将具体维度的抽象与系统聚合在一起</a>
</h3>
<h3 class="topic">
<a name="5gjlbi1cbn8tb98q7f4ss03tdp">&nbsp;&nbsp;区别适配器，桥接是考虑到对象复用时实现角度不同，聚合的时具体的实现抽象。适配器聚合的是另一个系统的接口</a>
</h3>
<h3 class="topic">
<a name="2ietu1kg1q5erf616v2n0kkb97">&nbsp;代理</a>
</h3>
<h3 class="topic">
<a name="00cd9i7ooue91n2qihuh9hefff">&nbsp;&nbsp;声明一个代理类，用友被代理类相同的方法（一般时是继承同一个接口）</a>
</h3>
<h3 class="topic">
<a name="60vldtnjkno7gcnlhd0ukkqjcq">&nbsp;&nbsp;方法的调用会优先经过代理类，从而达到功能增强的目的</a>
</h3>
<h3 class="topic">
<a name="3fcamsf9e7r6de45vl2n1l2v2c">&nbsp;&nbsp;spring中使用到jdk的动态代理和cglib的代理</a>
</h3>
<h3 class="topic">
<a name="6jj56eg28pp1utbfns6rf35b8v">&nbsp;&nbsp;&nbsp;jdk的代理必须要求被代理类是接口类，从而可以通过反射创建代理类</a>
</h3>
<h3 class="topic">
<a name="5btejcmnbkb12t2iccjokqlpo9">&nbsp;&nbsp;&nbsp;cglib只需要被代理类不是final，通过字节码增强，生成继承的子类</a>
</h3>
<h3 class="topic">
<a name="6qlj1gmo2j2qu1kshi7mmri499">&nbsp;享元</a>
</h3>
<h3 class="topic">
<a name="1qi02ffg624jp4b51bciqsc5ni">&nbsp;&nbsp;String常量池</a>
</h3>
<h2 class="topic">
<a name="7ddad1fpmen0804u87lrtgagpt">行为</a>
</h2>
<h3 class="topic">
<a name="4d81mmur0u3f9oo6ioh1git3pa">&nbsp;观察者</a>
</h3>
<h3 class="topic">
<a name="6h4pp3rj62cjoqm6oh9tdk5s7q">&nbsp;&nbsp;定义了一种一对多的依赖关系，让多个观察者同时监听某一个主题。</a>
</h3>
<h3 class="topic">
<a name="0ioe6020fdi8gb8qjmstalkn96">&nbsp;&nbsp;主题发生变化时，会通知观察者</a>
</h3>
<h3 class="topic">
<a name="7esodmp5gmn1kdurb5q2u59g0t">&nbsp;命令</a>
</h3>
<h3 class="topic">
<a name="4i3gpv8fiuv0v2dq4fqtdj3al6">&nbsp;&nbsp;将请求执行者和请求调用者解耦</a>
</h3>
<h3 class="topic">
<a name="4580u0domo8tafpspl4fctkha8">&nbsp;&nbsp;命令类内包含执行者。这样可以通过继承命令类扩展命令</a>
</h3>
<h3 class="topic">
<a name="0ffoa5teaj1213b2c2iehcs3m9">&nbsp;&nbsp;命令模式可以包含接受者，接受者可以包含多个命令，接受者可以缓存多个命令</a>
</h3>
<h3 class="topic">
<a name="0l6tcv3bc0vuvgktgg02jf16k4">&nbsp;责任链</a>
</h3>
<h3 class="topic">
<a name="757u0eeqg7n70dpmq5lu6tkn4n">&nbsp;&nbsp;定义了一个抽象处理接口，处理实现类内部聚合了下一个处理类</a>
</h3>
<h3 class="topic">
<a name="1924hm3od716gu2sbnucq57kop">&nbsp;&nbsp;将多个对象以链式方式串联，每个对象都有机会处理请求，每个请求都会顺着链路执行知道有处理类可以执行位置</a>
</h3>
<h3 class="topic">
<a name="6981524lpd1knui75quues7ur1">&nbsp;备忘录</a>
</h3>
<h3 class="topic">
<a name="2ce0dnr1olioe4an5m8l73tc6k">&nbsp;状态</a>
</h3>
<h3 class="topic">
<a name="2b2c6ssr4tlt1d81d7ar0uscaa">&nbsp;&nbsp;当一个对象内在状态变更时允许改变其行为</a>
</h3>
<h3 class="topic">
<a name="29i4nfb9tua8uir7idb9bqe6dr">&nbsp;&nbsp;将特定状体相关的行为放入一个对象中，新增子类可以很容易增加状态和变化</a>
</h3>
<h3 class="topic">
<a name="4eaafpifnrop9543m80t9kjigs">&nbsp;&nbsp;状体类的process方法会传入主体上下文，通过内在状态的变更改变对象主体</a>
</h3>
<h3 class="topic">
<a name="61aii5bii13c0qjejlh752q3bi">&nbsp;迭代</a>
</h3>
<h3 class="topic">
<a name="6sp9pfpultcmpthn95laqfgdbn">&nbsp;&nbsp;一个类内部不想暴露访问内部元素的方法，由迭代器完成，迭代器可以通过继承实现不同的遍历方式</a>
</h3>
<h3 class="topic">
<a name="6hsufjneu1kqrr5ki77lojvmeg">&nbsp;策略</a>
</h3>
<h3 class="topic">
<a name="4sd8mr3bkr0928qnd37rfj6g4g">&nbsp;中介</a>
</h3>
<h3 class="topic">
<a name="1pouj5p2s7dbit4ib8mi8n6a24">&nbsp;模板方法</a>
</h3>
<h3 class="topic">
<a name="13fudv1mehl4ni46p1fucoutfb">&nbsp;解释器</a>
</h3>
<h3 class="topic">
<a name="3m06i84865fdvj7t2e5acqrhcf">&nbsp;访问者</a>
</h3>




<h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>标记: 优先级 1</p>
<p>一般工厂：客户端传递需要生成的参数，由工厂类完成选择判断，生成具体的产品</p>
<p>工厂模式：转移了判断，将具体的工厂升级为抽象工厂，由客户端决定实例化哪个工厂，从而产生具体的产品</p>
<p>目标：解耦分离，将产品构造的逻辑封装在工厂中，使得工厂产生的对象能够相互独立修改，提高扩展性</p>
<p>对修改封闭（不需要修改工厂类）扩展开放（只需要继承工厂类）</p>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>标记: 优先级 1</p>
<p>通过工厂模式，实现了修改封闭和扩展开放，当有多条产品线时，抽象产品和工厂类之间就形成了抽象工厂</p>
<p>一般客户端需要负责选择具体的产品工厂，当需要更换产品线时，需要找到所有客户端，进行修改</p>
<p>优化方式：通过引入简单工厂，将客户端选择工厂的逻辑用工厂方法进行封装，同时将选择逻辑用常量、反射、配置文件加载的方式处理，统一暴露抽象产品接口。这样客户端只知道抽象产品，而不需要考虑产品生成过程</p>
<h3 id="建造者"><a href="#建造者" class="headerlink" title="建造者"></a>建造者</h3><p>标记: 优先级 1</p>
<p>将复杂的对象构建与表示分离，使得同样的的构建过程可以创建不同的表示</p>
<p>Builder是抽象步骤，提取了构建过程中必备的步骤</p>
<p>Director是指挥者，用来控制构建过程</p>
<p>用于创建一些复杂对象，这些对象内部的构建顺序通常是稳定的</p>
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>标记: 优先级 1</p>
<p>懒汉式</p>
<p>双重检查（变量由volatile修饰，获取实例时通过在加锁前后两次判断）</p>
<p>饿汉式</p>
<p>静态初始化，在类加载的时候就加载静态变量，避免了加锁，提前分配内存</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>就是对象clone</p>
<h2 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h2><h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>标记: 优先级 1</p>
<p>定义了一种一对多的依赖关系，让多个观察者同时监听某一个主题。</p>
<p>主题发生变化时，会通知观察者</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>标记: 优先级 1</p>
<p>将请求执行者和请求调用者解耦</p>
<p>命令类内包含执行者。这样可以通过继承命令类扩展命令</p>
<p>命令模式可以包含接受者，接受者可以包含多个命令，接受者可以缓存多个命令</p>
<h3 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h3><p>标记: 优先级 1</p>
<p>定义了一个抽象处理接口，处理实现类内部聚合了下一个处理类</p>
<p>将多个对象以链式方式串联，每个对象都有机会处理请求，每个请求都会顺着链路执行知道有处理类可以执行位置</p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>标记: 优先级 1</p>
<p>当一个对象内在状态变更时允许改变其行为</p>
<p>将特定状体相关的行为放入一个对象中，新增子类可以很容易增加状态和变化</p>
<p>状体类的process方法会传入主体上下文，通过内在状态的变更改变对象主体</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>一个类内部不想暴露访问内部元素的方法，由迭代器完成，迭代器可以通过继承实现不同的遍历方式</p>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>标记: 优先级 2</p>
<h3 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h3><h3 id="中介"><a href="#中介" class="headerlink" title="中介"></a>中介</h3><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><h3 id="访问者"><a href="#访问者" class="headerlink" title="访问者"></a>访问者</h3><h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>标记: 优先级 1</p>
<p>将对象组合成树的形式，使用用户对单个对象和组合对象的使用有一致性</p>
<p>透明模式，所有子对象实现的方法都相同</p>
<p>安全方式，某些叶子节点不需要实现的add，remove等增加子对象的方法不作为接口</p>
<h3 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h3><p>标记: 优先级 1</p>
<p>动态给一个对象添加一些额外的职责</p>
<p>通过对象组合的方式，增加对象的功能特性</p>
<p>需要装饰的对象&#x2F;行为抽象名为Component</p>
<p>装饰主体取名为Decorator，（简单理解为具体的装饰者）</p>
<p>Component的各种实现都是不同装饰程度的装饰体</p>
<h3 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h3><p>标记: 优先级 2</p>
<p>对内部子系统提供一个统一的对外一致性界面</p>
<p>适用于兼容历史系统，减少两个系统的依赖</p>
<p>两个系统接口不同</p>
<h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>标记: 优先级 2</p>
<p>兼容子系统，并提供相同的接口</p>
<p>偏向于维护阶段使用</p>
<h3 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h3><p>标记: 优先级 1</p>
<p>由于继承关系用有更强的耦合，当实现方式有多个维度时，考虑合成&#x2F;组合原则，将具体维度的抽象与系统聚合在一起</p>
<p>区别适配器，桥接是考虑到对象复用时实现角度不同，聚合的时具体的实现抽象。适配器聚合的是另一个系统的接口</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>标记: 优先级 2</p>
<p>声明一个代理类，用友被代理类相同的方法（一般时是继承同一个接口）</p>
<p>方法的调用会优先经过代理类，从而达到功能增强的目的</p>
<p>spring中使用到jdk的动态代理和cglib的代理</p>
<p>jdk的代理必须要求被代理类是接口类，从而可以通过反射创建代理类</p>
<p>通过Proxy.newProxyInstance(null, new Class[]{Comparable.class}, handler)来创建被代理对象</p>
<blockquote>
<p>其中<br>null是类加载器<br>interface是代理类需要实现的接口<br>handler是织入类，实现了InvocationHandler接口，并包含了被代理类实例</p>
<p>invoke方法签名(Object proxy, Method method, Object[] args)<br>proxy是生成的被代理类，method是调用方法，args是调用参数</p>
<p>cglib只需要被代理类不是final，通过字节码增强，生成继承的子类</p>
</blockquote>
<h3 id="享元"><a href="#享元" class="headerlink" title="享元"></a>享元</h3><p>String常量池</p>

                    
                </div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                    </div>
                    <div>
                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/4-%E5%AD%98%E5%82%A8%E7%BB%84%E4%BB%B6%E6%A6%82%E8%BF%B0/"
                                   title="4_存储组件概述"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">4_存储组件概述</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    






                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%A7%88"><span class="nav-text">概览</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E5%AD%97%E7%89%88"><span class="nav-text">文字版</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-text">
创建型
</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 工厂模式
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  一般工厂：客户端传递需要生成的参数，由工厂类完成选择判断，生成具体的产品
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  工厂模式：转移了判断，将具体的工厂升级为抽象工厂，由客户端决定实例化哪个工厂，从而产生具体的产品
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  目标：解耦分离，将产品构造的逻辑封装在工厂中，使得工厂产生的对象能够相互独立修改，提高扩展性
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  对修改封闭（不需要修改工厂类）扩展开放（只需要继承工厂类）
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 抽象工厂
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  通过工厂模式，实现了修改封闭和扩展开放，当有多条产品线时，抽象产品和工厂类之间就形成了抽象工厂
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  一般客户端需要负责选择具体的产品工厂，当需要更换产品线时，需要找到所有客户端，进行修改
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  优化方式：通过引入简单工厂，将客户端选择工厂的逻辑用工厂方法进行封装，同时将选择逻辑用常量、反射、配置文件加载的方式处理，统一暴露抽象产品接口。这样客户端只知道抽象产品，而不需要考虑产品生成过程
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 建造者
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  将复杂的对象构建与表示分离，使得同样的的构建过程可以创建不同的表示
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  Builder是抽象步骤，提取了构建过程中必备的步骤
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  Director是指挥者，用来控制构建过程
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  用于创建一些复杂对象，这些对象内部的构建顺序通常是稳定的
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 单例
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  懒汉式
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
   双重检查（变量由volatile修饰，获取实例时通过在加锁前后两次判断）
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  饿汉式
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
   静态初始化，在类加载的时候就加载静态变量，避免了加锁，提前分配内存
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 原型
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  就是对象clone
</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-text">
结构型
</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 组合
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  将对象组合成树的形式，使用用户对单个对象和组合对象的使用有一致性
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  透明模式，所有子对象实现的方法都相同
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  安全方式，某些叶子节点不需要实现的add，remove等增加子对象的方法不作为接口
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 装饰
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  动态给一个对象添加一些额外的职责
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  通过对象组合的方式，增加对象的功能特性
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  需要装饰的对象&#x2F;行为抽象名为Component
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  装饰主体取名为Decorator，（简单理解为具体的装饰者）
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  Component的各种实现都是不同装饰程度的装饰体
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 外观
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  对内部子系统提供一个统一的对外一致性界面
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  适用于兼容历史系统，减少两个系统的依赖
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  两个系统接口不同
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 适配器
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  兼容子系统，并提供相同的接口
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  偏向于维护阶段使用
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 桥接
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  由于继承关系用有更强的耦合，当实现方式有多个维度时，考虑合成&#x2F;组合原则，将具体维度的抽象与系统聚合在一起
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  区别适配器，桥接是考虑到对象复用时实现角度不同，聚合的时具体的实现抽象。适配器聚合的是另一个系统的接口
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 代理
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  声明一个代理类，用友被代理类相同的方法（一般时是继承同一个接口）
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  方法的调用会优先经过代理类，从而达到功能增强的目的
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  spring中使用到jdk的动态代理和cglib的代理
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
   jdk的代理必须要求被代理类是接口类，从而可以通过反射创建代理类
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
   cglib只需要被代理类不是final，通过字节码增强，生成继承的子类
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 享元
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  String常量池
</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-text">
行为
</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 观察者
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  定义了一种一对多的依赖关系，让多个观察者同时监听某一个主题。
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  主题发生变化时，会通知观察者
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 命令
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  将请求执行者和请求调用者解耦
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  命令类内包含执行者。这样可以通过继承命令类扩展命令
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  命令模式可以包含接受者，接受者可以包含多个命令，接受者可以缓存多个命令
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 责任链
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  定义了一个抽象处理接口，处理实现类内部聚合了下一个处理类
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  将多个对象以链式方式串联，每个对象都有机会处理请求，每个请求都会顺着链路执行知道有处理类可以执行位置
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 备忘录
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 状态
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  当一个对象内在状态变更时允许改变其行为
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  将特定状体相关的行为放入一个对象中，新增子类可以很容易增加状态和变化
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  状体类的process方法会传入主体上下文，通过内在状态的变更改变对象主体
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 迭代
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  一个类内部不想暴露访问内部元素的方法，由迭代器完成，迭代器可以通过继承实现不同的遍历方式
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 策略
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 中介
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 模板方法
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 解释器
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 访问者
</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B"><span class="nav-text">创建型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-text">工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82"><span class="nav-text">抽象工厂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85"><span class="nav-text">建造者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B"><span class="nav-text">单例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B"><span class="nav-text">原型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA"><span class="nav-text">行为</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85"><span class="nav-text">观察者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4"><span class="nav-text">命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE"><span class="nav-text">责任链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81"><span class="nav-text">状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3"><span class="nav-text">迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%96%E7%95%A5"><span class="nav-text">策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95"><span class="nav-text">备忘录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E4%BB%8B"><span class="nav-text">中介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95"><span class="nav-text">模板方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-text">解释器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85"><span class="nav-text">访问者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B"><span class="nav-text">结构型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88"><span class="nav-text">组合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0"><span class="nav-text">装饰</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E8%A7%82"><span class="nav-text">外观</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-text">适配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5"><span class="nav-text">桥接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86"><span class="nav-text">代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%AB%E5%85%83"><span class="nav-text">享元</span></a></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="copyright-info info-item">
        &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2025
        
            &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">EmiyaQ</a>
        
    </div>

    <div class="theme-info info-item">
        由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
    </div>

    

    

    
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="post-tools-list border-box">
        <!-- PC encrypt again -->
        

        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <!-- toggle mode -->
        
            <li class="tools-item tool-toggle-theme-mode flex-center">
                <i class="fas fa-moon"></i>
            </li>
        

        <!-- rss -->
        

        <!-- to bottom -->
        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%A7%88"><span class="nav-text">概览</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E5%AD%97%E7%89%88"><span class="nav-text">文字版</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-text">
创建型
</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 工厂模式
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  一般工厂：客户端传递需要生成的参数，由工厂类完成选择判断，生成具体的产品
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  工厂模式：转移了判断，将具体的工厂升级为抽象工厂，由客户端决定实例化哪个工厂，从而产生具体的产品
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  目标：解耦分离，将产品构造的逻辑封装在工厂中，使得工厂产生的对象能够相互独立修改，提高扩展性
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  对修改封闭（不需要修改工厂类）扩展开放（只需要继承工厂类）
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 抽象工厂
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  通过工厂模式，实现了修改封闭和扩展开放，当有多条产品线时，抽象产品和工厂类之间就形成了抽象工厂
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  一般客户端需要负责选择具体的产品工厂，当需要更换产品线时，需要找到所有客户端，进行修改
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  优化方式：通过引入简单工厂，将客户端选择工厂的逻辑用工厂方法进行封装，同时将选择逻辑用常量、反射、配置文件加载的方式处理，统一暴露抽象产品接口。这样客户端只知道抽象产品，而不需要考虑产品生成过程
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 建造者
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  将复杂的对象构建与表示分离，使得同样的的构建过程可以创建不同的表示
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  Builder是抽象步骤，提取了构建过程中必备的步骤
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  Director是指挥者，用来控制构建过程
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  用于创建一些复杂对象，这些对象内部的构建顺序通常是稳定的
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 单例
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  懒汉式
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
   双重检查（变量由volatile修饰，获取实例时通过在加锁前后两次判断）
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  饿汉式
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
   静态初始化，在类加载的时候就加载静态变量，避免了加锁，提前分配内存
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 原型
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  就是对象clone
</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-text">
结构型
</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 组合
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  将对象组合成树的形式，使用用户对单个对象和组合对象的使用有一致性
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  透明模式，所有子对象实现的方法都相同
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  安全方式，某些叶子节点不需要实现的add，remove等增加子对象的方法不作为接口
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 装饰
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  动态给一个对象添加一些额外的职责
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  通过对象组合的方式，增加对象的功能特性
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  需要装饰的对象&#x2F;行为抽象名为Component
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  装饰主体取名为Decorator，（简单理解为具体的装饰者）
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  Component的各种实现都是不同装饰程度的装饰体
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 外观
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  对内部子系统提供一个统一的对外一致性界面
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  适用于兼容历史系统，减少两个系统的依赖
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  两个系统接口不同
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 适配器
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  兼容子系统，并提供相同的接口
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  偏向于维护阶段使用
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 桥接
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  由于继承关系用有更强的耦合，当实现方式有多个维度时，考虑合成&#x2F;组合原则，将具体维度的抽象与系统聚合在一起
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  区别适配器，桥接是考虑到对象复用时实现角度不同，聚合的时具体的实现抽象。适配器聚合的是另一个系统的接口
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 代理
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  声明一个代理类，用友被代理类相同的方法（一般时是继承同一个接口）
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  方法的调用会优先经过代理类，从而达到功能增强的目的
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  spring中使用到jdk的动态代理和cglib的代理
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
   jdk的代理必须要求被代理类是接口类，从而可以通过反射创建代理类
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
   cglib只需要被代理类不是final，通过字节码增强，生成继承的子类
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 享元
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  String常量池
</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-text">
行为
</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 观察者
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  定义了一种一对多的依赖关系，让多个观察者同时监听某一个主题。
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  主题发生变化时，会通知观察者
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 命令
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  将请求执行者和请求调用者解耦
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  命令类内包含执行者。这样可以通过继承命令类扩展命令
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  命令模式可以包含接受者，接受者可以包含多个命令，接受者可以缓存多个命令
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 责任链
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  定义了一个抽象处理接口，处理实现类内部聚合了下一个处理类
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  将多个对象以链式方式串联，每个对象都有机会处理请求，每个请求都会顺着链路执行知道有处理类可以执行位置
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 备忘录
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 状态
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  当一个对象内在状态变更时允许改变其行为
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  将特定状体相关的行为放入一个对象中，新增子类可以很容易增加状态和变化
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  状体类的process方法会传入主体上下文，通过内在状态的变更改变对象主体
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 迭代
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
  一个类内部不想暴露访问内部元素的方法，由迭代器完成，迭代器可以通过继承实现不同的遍历方式
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 策略
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 中介
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 模板方法
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 解释器
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">
 访问者
</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B"><span class="nav-text">创建型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-text">工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82"><span class="nav-text">抽象工厂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85"><span class="nav-text">建造者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B"><span class="nav-text">单例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B"><span class="nav-text">原型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA"><span class="nav-text">行为</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85"><span class="nav-text">观察者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4"><span class="nav-text">命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE"><span class="nav-text">责任链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81"><span class="nav-text">状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3"><span class="nav-text">迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%96%E7%95%A5"><span class="nav-text">策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95"><span class="nav-text">备忘录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E4%BB%8B"><span class="nav-text">中介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95"><span class="nav-text">模板方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-text">解释器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85"><span class="nav-text">访问者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B"><span class="nav-text">结构型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88"><span class="nav-text">组合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0"><span class="nav-text">装饰</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E8%A7%82"><span class="nav-text">外观</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-text">适配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5"><span class="nav-text">桥接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86"><span class="nav-text">代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%AB%E5%85%83"><span class="nav-text">享元</span></a></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>





<!-- common js -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local search -->

    
<script src="/js/local-search.js"></script>



<!-- lazyload -->

    
<script src="/js/lazyload.js"></script>



<div class="">
    <!-- home page -->
    

    <!-- post page -->
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        
            
<script src="/js/post/toc.js"></script>

        

        <!-- copyright-info -->
        

        <!-- share -->
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->



</body>
</html>
