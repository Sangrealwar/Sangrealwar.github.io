<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="人生，总有些黑暗的隧道需要自己穿越">
    <meta name="author" content="EmiyaQ">
    
    <title>
        
            Java基础知识 |
        
        The winter sunshine
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.svg">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"The winter sunshine","author":"EmiyaQ","avatar":"/images/pig.png","logo":"/images/logo.svg","favicon":"/images/logo.svg"},"menu":{"home":"/","categories":"/categories"},"first_screen":{"enable":false,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"Keep writing and Keep loving.","hitokoto":false},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":false,"hide_header":true},"home":{"announcement":null,"category":true,"tag":true,"post_datetime":"updated"},"post":{"author_badge":{"enable":false,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":false,"min2read":false},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":false,"share":false,"reward":{"enable":false,"img_link":null,"text":null,"icon":null}},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":false,"site_uv":false,"site_pv":false,"page_pv":false}},"local_search":{"enable":true,"preload":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.36"},"waline":{"server_url":null,"reaction":false,"version":"3.2.1"},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":true},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":false},"footer":{"since":2020,"word_count":false,"site_deploy":{"enable":false,"provider":"github","url":null},"record":{"enable":false,"list":[{"code":null,"link":null}]}},"inject":{"enable":false,"css":[null],"js":[null]},"root":"","source_data":{},"version":"4.2.3"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left flex-start border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               The winter sunshine
            </a>
        </div>

        <div class="right border-box">
            <div class="pc border-box">
                <ul class="menu-list border-box">
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/">
                                
                                首页
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/categories">
                                
                                分类
                                
                            </a>
                            
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="menu-text-color fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile border-box flex-start">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list border-box">
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/">
                            
                            首页
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/categories">
                            
                            分类
                        </a>
                        
                    </label>
                    
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        Java基础知识
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/pig.png">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">EmiyaQ</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2024-04-13 22:14:05</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Sun Aug 11 2024 15:08:51 GMT+0800">2024-08-11 15:08:51</span>
            </span>
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/">通用知识</a></li>
                        
                    
                </ul>
            </span>
        

        

        
        
        
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body ">
                    

                    
                         <blockquote>
<p>2015年，jdk8虚拟机规范：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p>
</blockquote>
<h1 id="运行内存区"><a href="#运行内存区" class="headerlink" title="运行内存区"></a>运行内存区</h1><blockquote>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5</a></p>
</blockquote>
<ul>
<li><p>程序计数器</p>
<ul>
<li>因为java虚拟机需要通过多线程轮流切换，并分配处理器执行时间来实现多线程，在某一个时刻，一个处理器（一般来说也就是一个内核)只会执行一条指令，因此，为了线程切换后能回复到正确的位置，每条线程需要一个独立的程序计数器，各条线程之间互不影响。</li>
<li>【线程私有】</li>
<li>【异常】：这块区域是java中唯一没有规定任何OutOfMemoryError的区域</li>
</ul>
</li>
<li><p>虚拟机栈</p>
<ul>
<li>（也就是通常意义上讲的堆栈中的栈），<strong>生命周期与线程相同</strong>，每个方法在执行的同时创建一个栈帧，方法从调用到执行结束，对应着栈帧入栈到出栈的过程，里面存放着局部变量表，比方说各种基本类型，对象引用（这里这是一个引用，具体的对象信息还是在堆上）。</li>
<li>【线程私有】</li>
<li>【异常】：如果线程请求栈深度大于虚拟机允许的深度，将抛出StoackOverflowError异常，一般无限递归会报这个错。如果虚拟机栈允许动态扩展，但是扩展时无法申请足够的内存，会抛出OutOfMemoryError异常。</li>
</ul>
</li>
<li><p>本地方法栈</p>
<ul>
<li>和虚拟机栈类似，只不过本地方法栈是虚拟机为Native方法准备的。</li>
<li>【线程私有】</li>
<li>【异常】：如果线程请求栈深度大于虚拟机允许的深度，将抛出StoackOverflowError异常，一般无限递归会报这个错。如果虚拟机栈允许动态扩展，但是扩展时无法申请足够的内存，会抛出OutOfMemoryError异常。</li>
</ul>
</li>
<li><p>堆</p>
<ul>
<li>是java虚拟机所管理内存的最大的一块。在虚拟机启动时创建，几乎所有的对象实例都在这里分配内存，在物理上不是不连续的内存中，逻辑上时连续的，</li>
<li>【线程共享】</li>
<li>【异常】：如果堆中没有内存完成实例分配，而且堆无法扩展时，将会抛出OutOfMemoryError异常。</li>
</ul>
</li>
<li><p>方法区</p>
<ul>
<li>各线程共享区域，用于存放虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。这块区域比较模糊，不同的虚拟机实现逻辑不同，有的放在永久代，有的放到Native Memory。</li>
<li><strong>运行时常量池</strong>，是方法区的一部分，存放类的版本，字段，方法等描述信息。</li>
<li>【线程共享】</li>
<li>【异常】，当方法去无法满足内存分配需求，将抛出，OutOfMemoryError异常。</li>
</ul>
</li>
</ul>
<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><blockquote>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3</a></p>
</blockquote>
<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>Java内存模型，通过特定操作协议，对内存或高速缓存进行读写过程的一种描述。JMM是一种在对线程并发情况下对于共享变量读写的<strong>规范</strong>，屏蔽了不同操作系统的差异，而Jvm内存结构是处于Java虚拟机层面，是运行时对Java进程占用内存的逻辑划分。</p>
<h2 id="结构规范"><a href="#结构规范" class="headerlink" title="结构规范"></a>结构规范</h2><p>所有变量都存储在主内存中，每个线程还有自己的工作内存，线程的工作内存保存了该线程使用的变量的主内存副本，线程对变量的所有操作（读取，赋值等）都必须在工作内存中进行，不能直接读写主内存。不同线程也不能直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存完成</p>
<h2 id="三个特性"><a href="#三个特性" class="headerlink" title="三个特性"></a>三个特性</h2><ul>
<li>原子性</li>
</ul>
<p>除了64位的long和dubbo，在32位Jvm中，会将64位的数据读写分为2次32位来操作，导致可能不是原子的。（TODO 但大部分操作系统已经支持）</p>
<ul>
<li>可见性</li>
</ul>
<p>一个线程对共享变量做了修改后，其他线程立即能够看到该变量的修改</p>
<ul>
<li>有序性</li>
</ul>
<p>单线程环境下，即使发生指令重拍，所有硬件优化的前提必须遵守as-if-serial语义，但是多线程环境中，因为工作内存与主存同步延迟，或者重排序，会导致可见性问题。</p>
<h2 id="常用概念"><a href="#常用概念" class="headerlink" title="常用概念"></a>常用概念</h2><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><blockquote>
<p>相关的有happen-before的各种规则，其中比较常用的是volatile，volatile可以保证写入会被另一个线程可见。</p>
</blockquote>
<h3 id="硬件原理"><a href="#硬件原理" class="headerlink" title="硬件原理"></a>硬件原理</h3><p>内存屏障，缓存一致性协议MESI，总线嗅探</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul>
<li>除了使用volatile，还有什么方式可以触发内存屏障（synchronized，unsafe的内存屏障）</li>
<li>volatile修饰的变量，赋值操作是可以保证可见性，但取值赋值操作不能</li>
<li>DCL（dubbo check）时，静态变量需要用volatile修饰，防止初始化时，被指令重排，导致数据不一致<ul>
<li>本质是因为java初始化对象时有3步操作（1. 申请内存空间，2. 初始化变量，3.修改变量指针，指向内存地址）其中，3操作可能会被重排到2操作之前</li>
</ul>
</li>
</ul>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><blockquote>
<p>无特殊说明，默认指1.8版本的HotSpot虚拟机</p>
<p>参考资料：<a href="https://mp.weixin.qq.com/s?__biz=MzIwNDAyOTI2Nw==&amp;mid=2247494932&amp;idx=1&amp;sn=1e0a7a74e947dd03967c36cc3270f8a1&amp;chksm=96c4c128a1b3483e78405fa2b1cf2f2f901b91593c56fc4d6ee086eb1b7c8a27e4d9be1fbf7d&amp;token=2016670857&amp;lang=zh_CN#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIwNDAyOTI2Nw==&amp;mid=2247494932&amp;idx=1&amp;sn=1e0a7a74e947dd03967c36cc3270f8a1&amp;chksm=96c4c128a1b3483e78405fa2b1cf2f2f901b91593c56fc4d6ee086eb1b7c8a27e4d9be1fbf7d&amp;token=2016670857&amp;lang=zh_CN#rd</a> </p>
<p>查看默认配置</p>
<p>java -XX:+PrintFlagsInitial  -version | grep CMS</p>
<p>查看当前配置</p>
<p>java -XX:+PrintFlagsFinal -version | grep CMS</p>
</blockquote>
<h2 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h2><p>衡量收集器的三项重要指标：内存占用，停顿时间，吞吐量</p>
<blockquote>
<p> 吞吐量 = 运行用户代码时间 / (运行用户代码时间+运行垃圾收集时间)，高吞吐量移位着用户代码执行时间长</p>
</blockquote>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><ul>
<li>标记清理</li>
</ul>
<p>容易产生内存碎片</p>
<p><img src="/2024/04/13/5_Java%E5%9F%BA%E7%A1%80/10.png" alt loading="lazy"></p>
<ul>
<li>复制</li>
</ul>
<p>内存占用较高，不容易产生内存碎片</p>
<p><img src="/2024/04/13/5_Java%E5%9F%BA%E7%A1%80/11.png" alt loading="lazy"></p>
<ul>
<li>标记整理</li>
</ul>
<p>标记后，让所有对象向一端移动，再清理边界外区域</p>
<p><img src="/2024/04/13/5_Java%E5%9F%BA%E7%A1%80/12.png" alt loading="lazy"></p>
<h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><p>黑色：表示对象被标记存活，并且该对象所有引用都已经被扫描过。不应该被回收，不会引用任何白色对象</p>
<p>灰色：表示对象被标记存活，但其引用还没有全部被扫描，可能引用白色对象</p>
<p>白色：表示对象尚未被访问，初始所有对象都是白色</p>
<h3 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h3><blockquote>
<p>针对跨代引用，保存的是一种非收集区（如年轻代）指向收集区（如老年代）</p>
</blockquote>
<p>为了避免年轻代收集时，存在老年代的引用，从而导致高成本扫描老年代。这里使用记忆集存储，用位标记一块特定的内存块，标记内存块内存在跨代引用，成为”脏页”</p>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>在对象赋值时，在c++底层，会在更新前后增加类似aop的环绕通知，处理相关逻辑，如卡表，增量更新，原始快照（SATB）等。有的是同步（CMS的增量更新），有的是异步（G1的原始快照）</p>
<h2 id="经典收集器"><a href="#经典收集器" class="headerlink" title="经典收集器"></a>经典收集器</h2><table>
<thead>
<tr>
<th>收集器类型</th>
<th>并行/串行</th>
<th>年轻代/老年代</th>
<th>算法</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>串行</td>
<td>年轻代</td>
<td>标记复制</td>
<td>简单，无线程交互开销</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行</td>
<td>老年代</td>
<td>标记整理</td>
<td>同Serial</td>
</tr>
<tr>
<td>ParNew</td>
<td>并行</td>
<td>年轻代</td>
<td>标记复制</td>
<td>搭配CMS</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>并行</td>
<td>年轻代</td>
<td>标记复制</td>
<td>注重吞吐量</td>
</tr>
<tr>
<td>Paralled Old</td>
<td>并行</td>
<td>老年代</td>
<td>标记整理</td>
<td>注重吞吐量或处理器资源稀缺，与Parallel Scavenge搭配</td>
</tr>
</tbody></table>
<h2 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h2><blockquote>
<p>oracle介绍：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector</a></p>
<p>启用Cms收集器</p>
</blockquote>
<p>全称Concurrent Mark Sweep，1.4推出，在1.9标记弃用，14版本正式弃用，与ParNewGC（清理年轻代）配套使用。CMS是一种以获取最短回收停顿时间为目标的收集器。</p>
<p>CMS及之前的收集器对内存的划分</p>
<p><img src="/2024/04/13/5_Java%E5%9F%BA%E7%A1%80/14.png" alt loading="lazy"></p>
<ul>
<li>整体过程</li>
</ul>
<ol>
<li>初始标记（STW）。标记GC Root直接关联的对象；</li>
<li>并发标记。与用户线程并行，开始遍历GC Root对象；</li>
<li>重新标记（STW）。修正并发标记期间产生变动的记录（利用增量更新）；</li>
<li>并发清理。与用户线程并发</li>
<li>重置。准备下一轮收集</li>
</ol>
<ul>
<li><p>优势</p>
<ul>
<li>停顿时间短</li>
</ul>
</li>
<li><p>带来的问题</p>
<ul>
<li>对处理器资源敏感，需要消耗处理器算力</li>
<li>由于并行标记，有浮动垃圾，所以老年代需要预留空间，会有浪费空间的情况</li>
<li>为了避免浪费空间，可能导致预留空间过少，触发”并发失败”，因此会执行后备预案，采用”Serial Old”进行老年代清理</li>
<li>标记清理，可能存在内存碎片，因此，CMS不得不在FullGc时，执行内存合并，增大停顿时长</li>
</ul>
</li>
</ul>
<h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><blockquote>
<p> oracle介绍：<a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html</a> </p>
</blockquote>
<p>全称Garbage-First，1.7推出，开创了面向局部收集和基于Region的内存布局形式。面向大内存多核，期望建立 “停顿预测模型”的收集器，旨在能够支持指定在长度微M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒的目标。</p>
<p>内存分配模型：</p>
<p><img src="/2024/04/13/5_Java%E5%9F%BA%E7%A1%80/13.png" alt loading="lazy"></p>
<blockquote>
<p>内存被划分为相等大小的内存区，每个块有着自己的功能，但年轻代/老年代并没有固定的大小，更灵活。”化整为零”的思想。</p>
</blockquote>
<ul>
<li>整体过程</li>
</ul>
<ol>
<li>初始标记（STW）。标记GC Root可达的对象</li>
<li>并发标记。与用户线程并发扫描</li>
<li>重标记（STW），完成SATB记录</li>
<li>清理复制（STW），标记存活对象，完成空闲区分配，擦出记忆表，根据预期停顿时间指定回收计划，并将存活对象移动到新区域，然后清除旧空间</li>
</ol>
<ul>
<li>优势<ul>
<li>针对多个区而言，是标记复制，内存碎片少</li>
<li>按收益动态确定回收集，利于程序长时间运行</li>
</ul>
</li>
<li>带来的问题<ul>
<li>内存占用较高（比如记忆集）</li>
<li>小内存的情况下，写屏障等内部算法复杂，对用户线程负载较高（经验值，6G-8G使用G1</li>
</ul>
</li>
</ul>
<h2 id="其他收集器"><a href="#其他收集器" class="headerlink" title="其他收集器"></a>其他收集器</h2><ul>
<li>Shenandoah收集器<ul>
<li>号称G1的下一代</li>
<li>非oracle研发</li>
</ul>
</li>
<li>ZGC收集器<ul>
<li>染色指针</li>
<li>无跨代概念</li>
<li>停顿时间在几十毫秒</li>
</ul>
</li>
</ul>
<h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><p>使用姿势：a)方法块，b)代码块</p>
<p>在Object上提供了wait/notify/norifyAll，将Object当做监视器，所以每个对象都可以是一把锁</p>
<p>Object都有一个监视器，对象监视器</p>
<ul>
<li>非公平的，当都在申请锁时，最后一个会优先获取到锁</li>
<li>重量级锁，由于会造成用户态到内核态的切换（CAS是用户态操作）</li>
<li>轻量级锁，偏向锁，失败后会膨胀到重量锁</li>
<li>锁状态和标记存储在对象头里</li>
<li>由于有延迟偏向（4s），不是所有对象立刻会开启偏向锁状态</li>
</ul>
<h2 id="MarkWord"><a href="#MarkWord" class="headerlink" title="MarkWord"></a>MarkWord</h2><ul>
<li>Java对象结构如下</li>
</ul>
<p><img src="/2024/04/13/5_Java%E5%9F%BA%E7%A1%80/4.png" alt loading="lazy"></p>
<p>可以通过代码查看对象空间，需要引入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ClassLayout.parseInstance(lock).toPrintable());</span><br></pre></td></tr></table></figure>

<p>在64位虚拟机默认配置下（开启指针压缩），一个普通的对象内存结构如下（对象头8字节，类指针4字节）</p>
<p><img src="/2024/04/13/5_Java%E5%9F%BA%E7%A1%80/3.png" alt loading="lazy"></p>
<ul>
<li>MarkWord</li>
</ul>
<blockquote>
<p>markWord结构，hotspot源码位置markOop.hpp</p>
<p><a href="https://hg.openjdk.org/jdk8u/jdk8u/hotspot/file/69087d08d473/src/share/vm/oops/markOop.hpp" target="_blank" rel="noopener">https://hg.openjdk.org/jdk8u/jdk8u/hotspot/file/69087d08d473/src/share/vm/oops/markOop.hpp</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bit-format of an object header (most significant first, big endian layout below):</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  32 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//             size:32 ------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  64 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></span><br><span class="line"><span class="comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></span><br><span class="line"><span class="comment">//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>以64位举例</p>
<p><img src="/2024/04/13/5_Java%E5%9F%BA%E7%A1%80/1.png" alt loading="lazy"></p>
<h2 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h2><ul>
<li>如果调用了hashCode，则不能启用偏向锁，因为没有56bit存放了线程ID，没地方放hashCode，hashCode会存在线程栈帧中</li>
<li>偏向锁轻微竞争时，会升级为轻量级锁。当要升级为重量锁时，偏向锁会撤销为无锁状态，再进入下一阶段</li>
</ul>
<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><blockquote>
<p>java.util.concurrent包</p>
<p>下面主要有3类，atomic，locks，同步工具，线程池等</p>
<p>参考文献A：<a href="https://segmentfault.com/a/1190000015558984" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015558984</a> </p>
</blockquote>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>当前主要使用MESA模型的管程模型，以下是典型的管程模型，主要元素包括</p>
<ol>
<li>共享变量（互斥量）</li>
<li>入口等待队列（去获取锁）</li>
<li>条件队列</li>
<li>阻塞唤醒机制（阻塞后进入条件队列，唤醒后进入同步等待队列）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//条件队列/等待队列的队列节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>  </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1. 共享变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">//2. 等待队列的头节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">//2. 等待队列的尾节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span></span>&#123;</span><br><span class="line">  <span class="comment">//3. 第一个条件队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">  <span class="comment">//3. 最后一个条件队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 阻塞</span></span><br><span class="line">LockSupport.park(threadA)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 唤醒</span></span><br><span class="line">LockSupport.unpark(threadA);</span><br></pre></td></tr></table></figure>



<p><img src="/2024/04/13/5_Java%E5%9F%BA%E7%A1%80/2.png" alt loading="lazy"></p>
<blockquote>
<p>上文提到的Synchronized是jvm层面提供的管程实现，只有一个条件变量，ObjectMonitor（重量级锁），但由于需要上下文切换（重量级锁时），性能不好，且粒度较粗，无法自定义解锁，非公平。为此，juc包下，提供了AQS，全称：AbstractQueuedSynchronizer</p>
</blockquote>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>阻塞等待队列</li>
<li>共享/独占</li>
<li>公平/非公平</li>
<li>可重入</li>
<li>允许中断</li>
</ul>
<h2 id="基础锁（Lock）"><a href="#基础锁（Lock）" class="headerlink" title="基础锁（Lock）"></a>基础锁（Lock）</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><blockquote>
<p>典型的AQS锁实现</p>
</blockquote>
<ul>
<li>特点<ul>
<li>公平/非公平</li>
<li>可重入</li>
<li>多条件变量</li>
<li>可设置超时时间</li>
<li>可中断</li>
</ul>
</li>
<li>与Synchronized区别<ul>
<li>synchronized是jvm层面，ReentrantLock是jdk层面</li>
<li>synchronized的锁状态无法在代码中判断，ReentrantLock可以通过java.util.concurrent.locks.ReentrantLock#isLocked判断</li>
</ul>
</li>
</ul>
<h4 id="使用姿势"><a href="#使用姿势" class="headerlink" title="使用姿势"></a>使用姿势</h4><ul>
<li>公平锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        lock.lock();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"\t锁到了"</span>);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            lock.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t1.setName(<span class="string">"Thread"</span> + i);</span><br><span class="line">            t1.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">"主线程"</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Thread0	锁到了</span><br><span class="line">Thread3	锁到了</span><br><span class="line">Thread1	锁到了</span><br><span class="line">Thread2	锁到了</span><br><span class="line">Thread4	锁到了</span><br><span class="line">Thread0	锁到了</span><br><span class="line">Thread3	锁到了</span><br><span class="line">Thread1	锁到了</span><br><span class="line">Thread2	锁到了</span><br><span class="line">Thread4	锁到了</span><br><span class="line">Thread0	锁到了</span><br><span class="line">Thread3	锁到了</span><br></pre></td></tr></table></figure>

<ul>
<li>条件队列</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition c1 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"\t开始等待"</span>);</span><br><span class="line">                        c1.await();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"\t执行啦"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"中断了"</span>);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread t2= <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"\t开始等待"</span>);</span><br><span class="line">                        c1.await();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"\t执行啦"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"中断了"</span>);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"休息3秒钟"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"\t释放"</span>);</span><br><span class="line">                    c1.signal();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"\t再释放一个"</span>);</span><br><span class="line">                    c1.signal();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">"主线程"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Thread-<span class="number">0</span>	开始等待</span><br><span class="line">休息<span class="number">3</span>秒钟</span><br><span class="line">Thread-<span class="number">1</span>	开始等待</span><br><span class="line">	释放</span><br><span class="line">Thread-<span class="number">0</span>	执行啦</span><br><span class="line">	再释放一个</span><br><span class="line">Thread-<span class="number">1</span>	执行啦</span><br><span class="line">主线程</span><br></pre></td></tr></table></figure>

<h4 id="原理小结"><a href="#原理小结" class="headerlink" title="原理小结"></a>原理小结</h4><p>线程利用CAS判断state，尝试加锁，加锁成功后，设置独占属性。其他线程加锁失败，尾插法后加入等待队列，调用park等待。解锁时，更新state=0。公平是针对加锁时，不尝试CAS判断，立刻加入等待队列</p>
<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><blockquote>
<p>AQS实现，可重入读写锁，读读共享。读写，写读，写写互斥</p>
</blockquote>
<ul>
<li><p>特点</p>
<ul>
<li>可重入</li>
<li>公平/非公平</li>
<li>读取多余写的情况下，可能造成写饥饿</li>
</ul>
</li>
</ul>
<h4 id="使用姿势-1"><a href="#使用姿势-1" class="headerlink" title="使用姿势"></a>使用姿势</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;String, Integer&gt; m &#x3D; new TreeMap&lt;String, Integer&gt;();</span><br><span class="line">    private final ReentrantReadWriteLock rwl &#x3D; new ReentrantReadWriteLock();</span><br><span class="line">    private final ReentrantReadWriteLock.ReadLock r &#x3D; rwl.readLock();</span><br><span class="line">    private final ReentrantReadWriteLock.WriteLock w &#x3D; rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    public Integer get(String key) &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return m.get(key);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Integer put(String key, Integer value) &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return m.put(key, value);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="原理小结-1"><a href="#原理小结-1" class="headerlink" title="原理小结"></a>原理小结</h4><p>利用state的前后16位移位来区分共享读，独占写，高16位读，低16位写。高16位只记录重入次数，每个线程重入次数由ThreadLocal里面保存</p>
<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><blockquote>
<p>邮戳锁，1.8版本，基于版本号的读写锁，没有基于AQS，但原理类似，ReentrantReadWriteLock读写存在写饥饿（即多个线程读取，会导致写长时间无法获取锁），StampedLock利用版本号，可根据版本号走乐观读，减少加锁次数。</p>
</blockquote>
<ul>
<li><p>特点</p>
<ul>
<li>不可重入</li>
<li>不基于AQS实现</li>
<li>不支持条件变量</li>
<li>不支持公平/非公平</li>
<li>有3种模式，其中乐观读不会阻塞写</li>
<li>读写加锁后会返回邮戳（版本号），利用邮戳解锁</li>
<li>读写锁相互升级</li>
</ul>
</li>
</ul>
<h4 id="使用姿势-2"><a href="#使用姿势-2" class="headerlink" title="使用姿势"></a>使用姿势</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">private double x, y;</span><br><span class="line">    private final StampedLock sl &#x3D; new StampedLock();</span><br><span class="line"></span><br><span class="line">    void move(double deltaX, double deltaY) &#123;</span><br><span class="line">        &#x2F;&#x2F;写加锁</span><br><span class="line">        long stamp &#x3D; sl.writeLock();</span><br><span class="line">        try &#123;</span><br><span class="line">            x +&#x3D; deltaX;</span><br><span class="line">            y +&#x3D; deltaY;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            sl.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double distanceFromOrigin() &#123;</span><br><span class="line">        &#x2F;&#x2F;乐观读锁</span><br><span class="line">        long stamp &#x3D; sl.tryOptimisticRead();</span><br><span class="line">        double currentX &#x3D; x, currentY &#x3D; y;</span><br><span class="line">        if (!sl.validate(stamp)) &#123;</span><br><span class="line">            &#x2F;&#x2F;发现读取完被修改，则改为读加锁</span><br><span class="line">            stamp &#x3D; sl.readLock();</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;加锁读取</span><br><span class="line">                currentX &#x3D; x;</span><br><span class="line">                currentY &#x3D; y;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sl.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double read() &#123;</span><br><span class="line">        long stamp &#x3D; sl.readLock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;加锁读取</span><br><span class="line">            double currentX &#x3D; x;</span><br><span class="line">            double currentY &#x3D; y;</span><br><span class="line">            return Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            sl.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void moveIfAtOrigin(double newX, double newY) &#123; </span><br><span class="line">        &#x2F;&#x2F; 锁升级，从读锁升级到写锁</span><br><span class="line">        long stamp &#x3D; sl.readLock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (x &#x3D;&#x3D; 0.0 &amp;&amp; y &#x3D;&#x3D; 0.0) &#123;</span><br><span class="line">                long ws &#x3D; sl.tryConvertToWriteLock(stamp);</span><br><span class="line">                if (ws !&#x3D; 0L) &#123;</span><br><span class="line">                    stamp &#x3D; ws;</span><br><span class="line">                    x &#x3D; newX;</span><br><span class="line">                    y &#x3D; newY;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                    stamp &#x3D; sl.writeLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            sl.unlock(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        StampedLockTest test &#x3D; new StampedLockTest();</span><br><span class="line"></span><br><span class="line">       CountDownLatch countDownLatch &#x3D; new CountDownLatch(25);</span><br><span class="line"></span><br><span class="line">        AtomicLong writeTime &#x3D; new AtomicLong();</span><br><span class="line">        AtomicLong readTime &#x3D; new AtomicLong();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            Thread t2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    int k &#x3D; 0;</span><br><span class="line">                    long sumTime &#x3D; 0;</span><br><span class="line">                    while (k &lt; 200) &#123;</span><br><span class="line">                        randomSleep();</span><br><span class="line">                        long start &#x3D; System.currentTimeMillis();</span><br><span class="line">                        &#x2F;&#x2F;使用乐观读</span><br><span class="line">&#x2F;&#x2F;                        test.distanceFromOrigin();</span><br><span class="line">                        &#x2F;&#x2F;使用悲观读</span><br><span class="line">                        test.read();</span><br><span class="line">                        long l &#x3D; System.currentTimeMillis();</span><br><span class="line">                        if ((l - start) &gt; 0) &#123;</span><br><span class="line">                            sumTime +&#x3D; (l - start);</span><br><span class="line">                        &#125;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    readTime.addAndGet(sumTime);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t2.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            Thread t1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    int k &#x3D; 0;</span><br><span class="line">                    long sumTime &#x3D; 0;</span><br><span class="line">                    while (k &lt; 200) &#123;</span><br><span class="line">                        randomSleep();</span><br><span class="line">                        long start &#x3D; System.currentTimeMillis();</span><br><span class="line">                        &#x2F;&#x2F;写</span><br><span class="line">                        test.move(1, 1);</span><br><span class="line">                        long l &#x3D; System.currentTimeMillis();</span><br><span class="line">                        if ((l - start) &gt; 0) &#123;</span><br><span class="line">                            sumTime +&#x3D; (l - start);</span><br><span class="line">                        &#125;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    writeTime.addAndGet(sumTime);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t1.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;运行完成，读\t&quot;+readTime.get()+&quot;\t写\t&quot;+writeTime.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void randomSleep() throws InterruptedException &#123;</span><br><span class="line">        Random random &#x3D; new Random();</span><br><span class="line">        int i &#x3D; random.nextInt(5);</span><br><span class="line">        Thread.sleep(i * 10);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="原理小结-2"><a href="#原理小结-2" class="headerlink" title="原理小结"></a>原理小结</h4><p>本质上读取并没有加锁，读加锁时，前一个如果也是读节点，会加入读节点的cowait字段，采用头插法。因此被唤醒的是最后插入的节点。唤醒时同理，如果是读节点，会将cowait的栈都唤醒</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="常见问题-2"><a href="#常见问题-2" class="headerlink" title="常见问题"></a>常见问题</h4><p>公平：加锁时，如果有等待队列，是否要乖乖排队。唤醒时都是固定逻辑，大部分是从等待队列队首开始唤醒</p>
<p>可重入：当线程再次加锁时，是否能够正常进入，可重入表示当前线程可以再次加锁成功</p>
<p>共享锁：共享变量能够有多个线程来加锁，例如ReentrantReadWriteLock的读锁</p>
<h4 id="简单对比"><a href="#简单对比" class="headerlink" title="简单对比"></a>简单对比</h4><table>
<thead>
<tr>
<th></th>
<th>AQS</th>
<th>ReentrantLock</th>
<th>ReentrantReadWriteLock</th>
<th>StampedLock</th>
</tr>
</thead>
<tbody><tr>
<td>条件变量</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>公平</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>共享变量（独占）</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>共享变量（共享）</td>
<td></td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>锁超时</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>可重入</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>读读共享</td>
<td></td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>乐观读</td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
</tbody></table>
<h2 id="同步工具"><a href="#同步工具" class="headerlink" title="同步工具"></a>同步工具</h2><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><blockquote>
<p>同步工具类，信号量，主要用于单机限流，基于AQS</p>
</blockquote>
<ul>
<li>特点<ul>
<li>公平/非公平</li>
<li>可重入</li>
<li>可设置超时时间</li>
<li>可中断</li>
<li>共享变量获取资源-1（利用AQS的state）</li>
<li>唤醒</li>
</ul>
</li>
</ul>
<h4 id="使用姿势-3"><a href="#使用姿势-3" class="headerlink" title="使用姿势"></a>使用姿势</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   semaphore.acquireUninterruptibly();</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                   &#125;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">"\t执行啦"</span>);</span><br><span class="line">                   semaphore.release();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           t1.start();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="原理小结-3"><a href="#原理小结-3" class="headerlink" title="原理小结"></a>原理小结</h4><p>利用AQS的state实现共享锁，获取和释放资源时，利用CAS修改变量，共享模式时，当之前阻塞被唤醒后，当前线程准备执行前，会把当前节点移除，并传播唤醒后继节点，然后回到业务线程。</p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><blockquote>
<p>闭锁，基于AQS</p>
</blockquote>
<ul>
<li>特点<ul>
<li>非公平</li>
<li>可设置超时时间</li>
<li>可中断</li>
<li>共享变量（利用AQS的state）</li>
</ul>
</li>
</ul>
<h4 id="使用姿势-4"><a href="#使用姿势-4" class="headerlink" title="使用姿势"></a>使用姿势</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> numThreads = <span class="number">5</span>;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(numThreads);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 运行"</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">"全部运行完成"</span>);	</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Thread-<span class="number">0</span> 运行</span><br><span class="line">Thread-<span class="number">2</span> 运行</span><br><span class="line">Thread-<span class="number">1</span> 运行</span><br><span class="line">Thread-<span class="number">4</span> 运行</span><br><span class="line">Thread-<span class="number">3</span> 运行</span><br><span class="line">全部运行完成</span><br></pre></td></tr></table></figure>

<h4 id="原理小结-4"><a href="#原理小结-4" class="headerlink" title="原理小结"></a>原理小结</h4><p>利用State记录闭锁的资源数，加锁解锁时，都按照固定逻辑操作资源数，释放掉所有资源后，加锁方法（await）才能顺利操作。和join类似，但join是循环判断线程是否存活，相比之下，CountDownLatch比较灵活，避免死锁。</p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><blockquote>
<p>循环栅栏，基于ReentrantLock和Condition</p>
</blockquote>
<ul>
<li>特点<ul>
<li>非公平</li>
<li>可设置超时时间</li>
<li>可中断</li>
<li>可重复达到条件</li>
<li>可设置达到条件时触发的异步方法</li>
</ul>
</li>
</ul>
<h4 id="使用姿势-5"><a href="#使用姿势-5" class="headerlink" title="使用姿势"></a>使用姿势</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"达到一次啦"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        cyclicBarrier.await();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"\t开始运行"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">达到一次啦</span><br><span class="line">Thread-<span class="number">2</span>	开始运行</span><br><span class="line">Thread-<span class="number">1</span>	开始运行</span><br><span class="line">Thread-<span class="number">0</span>	开始运行</span><br><span class="line">达到一次啦</span><br><span class="line">Thread-<span class="number">5</span>	开始运行</span><br><span class="line">Thread-<span class="number">3</span>	开始运行</span><br><span class="line">Thread-<span class="number">4</span>	开始运行</span><br></pre></td></tr></table></figure>

<h4 id="原理小结-5"><a href="#原理小结-5" class="headerlink" title="原理小结"></a>原理小结</h4><p>（假设3个变量，Thread0，Thread1）await()方法内部会先通过ReentrantLock加锁，然后进入dowait方法，dowait方法内部调用Condition的await方法，将当前线程加入条件队列尾部，同时释放锁，然后阻塞线程。当有多个线程进入条件队列，且满足数量后。最后那个线程（Thread2）会在dowait方法内部，触发Condition的signalAll，将这个线程从条件队列中，转移到同步队列（从头部开始转），在Thread的unlock方法时，会唤醒下一个线程</p>
<h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><blockquote>
<p>交换器</p>
</blockquote>
<ul>
<li>特点<ul>
<li>用于两个线程之间交换数据</li>
</ul>
</li>
</ul>
<h4 id="使用姿势-6"><a href="#使用姿势-6" class="headerlink" title="使用姿势"></a>使用姿势</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Exchanger&lt;Message&gt; exchanger &#x3D; new Exchanger&lt;&gt;();</span><br><span class="line">        Thread t1 &#x3D; new Thread(new Consumer(exchanger), &quot;消费者-t1&quot;);</span><br><span class="line">        Thread t2 &#x3D; new Thread(new Producer(exchanger), &quot;生产者-t2&quot;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Producer implements Runnable &#123;</span><br><span class="line">        private final Exchanger&lt;Message&gt; exchanger;</span><br><span class="line"></span><br><span class="line">        public Producer(Exchanger&lt;Message&gt; exchanger) &#123;</span><br><span class="line">            this.exchanger &#x3D; exchanger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Message message &#x3D; new Message();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">                    message.setCall(String.valueOf(i));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;: 生产了数据[&quot; + i + &quot;]&quot;);</span><br><span class="line">                    message &#x3D; exchanger.exchange(message);</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;: 交换得到数据[&quot; + message.getBack() + &quot;]&quot;);</span><br><span class="line"></span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Consumer implements Runnable &#123;</span><br><span class="line">        private final Exchanger&lt;Message&gt; exchanger;</span><br><span class="line"></span><br><span class="line">        public Consumer(Exchanger&lt;Message&gt; exchanger) &#123;</span><br><span class="line">            this.exchanger &#x3D; exchanger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Message msg &#x3D; new Message();</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    msg &#x3D; exchanger.exchange(msg);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;: 消费了数据[&quot; + msg.getCall() + &quot;]&quot;);</span><br><span class="line">                    msg.setBack(&quot;back&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Message &#123;</span><br><span class="line">        String call;</span><br><span class="line">        String back;</span><br><span class="line"></span><br><span class="line">        public String getCall() &#123;</span><br><span class="line">            return call;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setCall(String call) &#123;</span><br><span class="line">            this.call &#x3D; call;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getBack() &#123;</span><br><span class="line">            return back;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setBack(String back) &#123;</span><br><span class="line">            this.back &#x3D; back;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">生产者-t2: 生产了数据[0]</span><br><span class="line">生产者-t2: 交换得到数据[null]</span><br><span class="line">消费者-t1: 消费了数据[0]</span><br><span class="line">生产者-t2: 生产了数据[1]</span><br><span class="line">消费者-t1: 消费了数据[1]</span><br><span class="line">生产者-t2: 交换得到数据[back]</span><br><span class="line">生产者-t2: 生产了数据[2]</span><br><span class="line">生产者-t2: 交换得到数据[back]</span><br><span class="line">消费者-t1: 消费了数据[2]</span><br></pre></td></tr></table></figure>

<h4 id="原理小结-6"><a href="#原理小结-6" class="headerlink" title="原理小结"></a>原理小结</h4><p>单槽交换比较简单，消费者线程先进来时，会通过CAS占用slot字段，并自旋一段时间（尽量少阻塞）后，进入阻塞阶段，当生产者线程进来后，会将slot置空，并把数据放在node对象的match字段里，唤醒消费者线程。</p>
<p>多槽交换类似，不过略微复杂，当CPU核数&gt;1或多槽竞争失败时，会升级为多槽交换</p>
<h3 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h3><blockquote>
<p>阶段拦截，1.7版本新增的同步工具类，相比CountDownLatch和CyclicBarrier，Phaser可以中途阶段升级。</p>
</blockquote>
<h4 id="使用姿势-7"><a href="#使用姿势-7" class="headerlink" title="使用姿势"></a>使用姿势</h4><p>模拟countDownLatch示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">        final Phaser phaser &#x3D; new Phaser();</span><br><span class="line">&#x2F;&#x2F;        final Phaser phaser &#x3D; new Phaser(1); &#x2F;&#x2F; &quot;1&quot; to register self</span><br><span class="line">        List&lt;Runnable&gt; tasks &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            phaser.register();</span><br><span class="line">            int finalI &#x3D; i;</span><br><span class="line">            Runnable runnable &#x3D; new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    System.out.println(&quot;输出&quot;+ finalI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            tasks.add(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; create and start threads</span><br><span class="line">        for (final Runnable task : tasks) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                phaser.arriveAndAwaitAdvance(); &#x2F;&#x2F; await all creation</span><br><span class="line">                task.run();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        phaser.arriveAndDeregister();   &#x2F;&#x2F;相当于协调者，到达后直接开始</span><br><span class="line">        System.out.println(&quot;输出完成&quot;);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">输出完成</span><br><span class="line">输出0</span><br><span class="line">输出2</span><br><span class="line">输出4</span><br><span class="line">输出1</span><br><span class="line">输出3</span><br></pre></td></tr></table></figure>

<p>循环到达阶段示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">        List&lt;Runnable&gt; tasks &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            int finalI &#x3D; i;</span><br><span class="line">            Runnable runnable &#x3D; new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    System.out.println(&quot;输出&quot; + finalI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            tasks.add(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;阶段向前提前3次。一共执行4次</span><br><span class="line">        final int iterations &#x3D; 3;</span><br><span class="line"></span><br><span class="line">        final Phaser phaser &#x3D; new Phaser() &#123;</span><br><span class="line">            protected boolean onAdvance(int phase, int registeredParties) &#123;</span><br><span class="line">                System.out.println(&quot;onAdvance\t&quot;+phase);</span><br><span class="line">                return phase &gt;&#x3D; iterations || registeredParties &#x3D;&#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        phaser.register();</span><br><span class="line">        for (final Runnable task : tasks) &#123;</span><br><span class="line">            phaser.register();</span><br><span class="line">            new Thread() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                        phaser.arriveAndAwaitAdvance();</span><br><span class="line">                    &#125; while (!phaser.isTerminated());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        phaser.arriveAndDeregister(); &#x2F;&#x2F; deregister self, don&#39;t wait</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">输出0</span><br><span class="line">输出2</span><br><span class="line">输出1</span><br><span class="line">输出3</span><br><span class="line">输出4</span><br><span class="line">onAdvance	0</span><br><span class="line">输出4</span><br><span class="line">输出3</span><br><span class="line">输出0</span><br><span class="line">输出2</span><br><span class="line">输出1</span><br><span class="line">onAdvance	1</span><br><span class="line">输出1</span><br><span class="line">输出4</span><br><span class="line">输出2</span><br><span class="line">输出0</span><br><span class="line">输出3</span><br><span class="line">onAdvance	2</span><br><span class="line">输出3</span><br><span class="line">输出4</span><br><span class="line">输出1</span><br><span class="line">输出2</span><br><span class="line">输出0</span><br><span class="line">onAdvance	3</span><br></pre></td></tr></table></figure>

<p>分层阶段示例，当达到下一层阶段时，触发上一层（parent）阶段跨越，每个phaser对应最多4个线程，超出部分则会创建下一个阶段，并且保持当所有线程（10个）都执行完成，才会跃迁（advance）到下一个阶段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">private static final int TASKS_PER_PHASER &#x3D; 4;      &#x2F;&#x2F; 每个Phaser对象对应的工作线程（任务）数</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        int repeats &#x3D; 3;    &#x2F;&#x2F; 指定任务最多执行的次数</span><br><span class="line">        Phaser phaser &#x3D; new Phaser() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected boolean onAdvance(int phase, int registeredParties) &#123;</span><br><span class="line">                System.out.println(&quot;---------------PHASE[&quot; + phase + &quot;],Parties[&quot; + registeredParties + &quot;] ---------------&quot;);</span><br><span class="line">                return phase + 1 &gt;&#x3D; repeats || registeredParties &#x3D;&#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Tasker[] taskers &#x3D; new Tasker[10];</span><br><span class="line">        build(taskers, 0, taskers.length, phaser);       &#x2F;&#x2F; 根据任务数,为每个任务分配Phaser对象</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; taskers.length; i++) &#123;          &#x2F;&#x2F; 执行任务</span><br><span class="line">            Thread thread &#x3D; new Thread(taskers[i]);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void build(Tasker[] taskers, int lo, int hi, Phaser phaser) &#123;</span><br><span class="line">        if (hi - lo &gt; TASKS_PER_PHASER) &#123;</span><br><span class="line">            for (int i &#x3D; lo; i &lt; hi; i +&#x3D; TASKS_PER_PHASER) &#123;</span><br><span class="line">                int j &#x3D; Math.min(i + TASKS_PER_PHASER, hi);</span><br><span class="line">                build(taskers, i, j, new Phaser(phaser));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i &#x3D; lo; i &lt; hi; ++i) &#123;</span><br><span class="line">                taskers[i] &#x3D; new Tasker(i, phaser);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Tasker implements Runnable &#123;</span><br><span class="line">        private final Phaser phaser;</span><br><span class="line">        private int count;</span><br><span class="line"></span><br><span class="line">        Tasker(Phaser phaser) &#123;</span><br><span class="line">            this.phaser &#x3D; phaser;</span><br><span class="line">            this.phaser.register();</span><br><span class="line">        &#125;</span><br><span class="line">        Tasker(int i,Phaser phaser) &#123;</span><br><span class="line">            this.count &#x3D; i;</span><br><span class="line">            this.phaser &#x3D; phaser;</span><br><span class="line">            this.phaser.register();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (!phaser.isTerminated()) &#123;   &#x2F;&#x2F;只要Phaser没有终止, 各个线程的任务就会一直执行</span><br><span class="line">                int i &#x3D; phaser.arriveAndAwaitAdvance();     &#x2F;&#x2F; 等待其它参与者线程到达</span><br><span class="line">                &#x2F;&#x2F; do something</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;: 执行完任务,count&#x3D;&quot;+count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">---------------PHASE[0],Parties[3] ---------------</span><br><span class="line">Thread-9: 执行完任务,count&#x3D;9</span><br><span class="line">Thread-0: 执行完任务,count&#x3D;0</span><br><span class="line">Thread-2: 执行完任务,count&#x3D;2</span><br><span class="line">Thread-3: 执行完任务,count&#x3D;3</span><br><span class="line">Thread-1: 执行完任务,count&#x3D;1</span><br><span class="line">Thread-5: 执行完任务,count&#x3D;5</span><br><span class="line">Thread-6: 执行完任务,count&#x3D;6</span><br><span class="line">Thread-4: 执行完任务,count&#x3D;4</span><br><span class="line">Thread-8: 执行完任务,count&#x3D;8</span><br><span class="line">Thread-7: 执行完任务,count&#x3D;7</span><br><span class="line">---------------PHASE[1],Parties[3] ---------------</span><br><span class="line">Thread-7: 执行完任务,count&#x3D;7</span><br><span class="line">Thread-8: 执行完任务,count&#x3D;8</span><br><span class="line">Thread-2: 执行完任务,count&#x3D;2</span><br><span class="line">Thread-9: 执行完任务,count&#x3D;9</span><br><span class="line">Thread-0: 执行完任务,count&#x3D;0</span><br><span class="line">Thread-5: 执行完任务,count&#x3D;5</span><br><span class="line">Thread-3: 执行完任务,count&#x3D;3</span><br><span class="line">Thread-6: 执行完任务,count&#x3D;6</span><br><span class="line">Thread-4: 执行完任务,count&#x3D;4</span><br><span class="line">Thread-1: 执行完任务,count&#x3D;1</span><br><span class="line">---------------PHASE[2],Parties[3] ---------------</span><br><span class="line">Thread-6: 执行完任务,count&#x3D;6</span><br><span class="line">Thread-9: 执行完任务,count&#x3D;9</span><br><span class="line">Thread-7: 执行完任务,count&#x3D;7</span><br><span class="line">Thread-5: 执行完任务,count&#x3D;5</span><br><span class="line">Thread-0: 执行完任务,count&#x3D;0</span><br><span class="line">Thread-2: 执行完任务,count&#x3D;2</span><br><span class="line">Thread-1: 执行完任务,count&#x3D;1</span><br><span class="line">Thread-4: 执行完任务,count&#x3D;4</span><br><span class="line">Thread-8: 执行完任务,count&#x3D;8</span><br><span class="line">Thread-3: 执行完任务,count&#x3D;3</span><br></pre></td></tr></table></figure>



<h4 id="原理小结-7"><a href="#原理小结-7" class="headerlink" title="原理小结"></a>原理小结</h4><p>和AQS类似，内部依然保留了同步等待队列，只不过是用链表存储，内部保存奇偶两个链表evenQ，oddQ，根据阶段来区分，奇数阶段oddQ，偶数阶段在evenQ，如果是分层，下层的Phaser共享根节点的链表。当线程数没有到达注册数量时，会采用头插法加入链表，会同步等待（利用的是ForkJoinPool的managedBlock，底层也是park）。当达到注册数量后，最后一个线程会按链表顺序，从顶部以此唤醒（unpark）其他节点，结合头插法，因此是后进先出，栈的形式。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><h4 id="简单对比-1"><a href="#简单对比-1" class="headerlink" title="简单对比"></a>简单对比</h4><table>
<thead>
<tr>
<th>业务诉求</th>
<th>Semaphore</th>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
<th>Exchanger</th>
<th>Phaser</th>
</tr>
</thead>
<tbody><tr>
<td>多线程阻塞共享额度</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>到达一定数量后唤醒另一个线程</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>到达一定数量后唤醒另一个线程，可重复使用</td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>到达一定阶段后唤醒线程，升级阶段，参与线程数可变化</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>两个线程交换数据</td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
</tr>
</tbody></table>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><blockquote>
<p>常用线程池，继承自AbstractExecutorService，有任务需要执行时，会将任务分配给线程，如果当下没有线程，泽辉放入队列，等待线程可用时，取出任务执行。</p>
</blockquote>
<ul>
<li>特点<ul>
<li>线程复用，减少系统因为频繁创建和销毁线程带来的开销</li>
</ul>
</li>
</ul>
<h4 id="使用姿势-8"><a href="#使用姿势-8" class="headerlink" title="使用姿势"></a>使用姿势</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor thread &#x3D; new ThreadPoolExecutor(2,</span><br><span class="line">        5,</span><br><span class="line">        1,</span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line">        new LinkedBlockingDeque&lt;&gt;(1),</span><br><span class="line">        new ThreadFactoryOne(),</span><br><span class="line">        new ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line">for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">    thread.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;：我在运行&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;运行完了&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="原理小结-8"><a href="#原理小结-8" class="headerlink" title="原理小结"></a>原理小结</h4><p><img src="/2024/04/13/5_Java%E5%9F%BA%E7%A1%80/5.png" alt loading="lazy"></p>
<h5 id="线程池构造器"><a href="#线程池构造器" class="headerlink" title="线程池构造器"></a>线程池构造器</h5><ul>
<li>核心线程 corePoolSize</li>
<li>最大线程数 maximumPoolSize</li>
<li>空闲线程存活时间 keepAliveTime</li>
<li>空闲线程存活时间单位 unit</li>
<li>任务队列 workQueue</li>
<li>线程工厂 threadFactory</li>
<li>拒绝策略 handler</li>
</ul>
<h5 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h5><p>包括线程池状态以及工作线程数的管理变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">private static final int COUNT_BITS &#x3D; Integer.SIZE - 3;    &#x2F;&#x2F;存放线程数位数 32-3&#x3D;29位</span><br><span class="line">private static final int CAPACITY   &#x3D; (1 &lt;&lt; COUNT_BITS) - 1; &#x2F;&#x2F;最大线程数	2^29-1 个线程</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; runState is stored in the high-order bits</span><br><span class="line">&#x2F;&#x2F; 线程运行状态，存储在高3位</span><br><span class="line">private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 111 00000 00000000 00000000 00000000</span><br><span class="line">private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 000 00000 00000000 00000000 00000000</span><br><span class="line">private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 001 00000 00000000 00000000 00000000</span><br><span class="line">private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 010 00000 00000000 00000000 00000000</span><br><span class="line">private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 011 00000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure>

<p>工作线程（Worker）继承自AbstractQueuedSynchronizer，与Thread关联，实际执行委托给runWorker方法</p>
<p>提供默认的线程工厂，便于设置线程名称，优先级，是否守护线程等</p>
<h5 id="线程执行"><a href="#线程执行" class="headerlink" title="线程执行"></a>线程执行</h5><p>核心execute方法</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command<span class="operator"> == </span>null)</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">NullPointerException()</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">int</span> c = ctl.get<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">if</span> (worker<span class="constructor">CountOf(<span class="params">c</span>)</span> &lt; corePoolSize) &#123;              <span class="comment">// CASE1: 工作线程数 &lt; 核心线程池上限</span></span><br><span class="line">        <span class="keyword">if</span> (add<span class="constructor">Worker(<span class="params">command</span>, <span class="params">true</span>)</span>)             <span class="comment">// 添加工作线程并执行</span></span><br><span class="line">            return;</span><br><span class="line">        c = ctl.get<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 加入线程失败 工作线程数 &gt;= 核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (is<span class="constructor">Running(<span class="params">c</span>)</span><span class="operator"> &amp;&amp; </span>workQueue.offer(command)) &#123;     <span class="comment">// CASE2: 插入任务至队列</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 再次检查线程池状态</span></span><br><span class="line">        <span class="built_in">int</span> recheck = ctl.get<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span> (!is<span class="constructor">Running(<span class="params">recheck</span>)</span><span class="operator"> &amp;&amp; </span>remove(command))    <span class="comment">//线程池非运行状态，移除任务，拒绝请求</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (worker<span class="constructor">CountOf(<span class="params">recheck</span>)</span><span class="operator"> == </span><span class="number">0</span>)          <span class="comment">//dubbocheck，在工作的线程数是否=0</span></span><br><span class="line">            add<span class="constructor">Worker(<span class="params">null</span>, <span class="params">false</span>)</span>;                    <span class="comment">//没有工作线程，就创建一个工作线程（非核心），让工作线程去队列获取任务</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!add<span class="constructor">Worker(<span class="params">command</span>, <span class="params">false</span>)</span>)        <span class="comment">// CASE3: 插入队列失败, 判断工作线程数 &lt; 总线程池上限</span></span><br><span class="line">        reject(command);    <span class="comment">// 执行拒绝策略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结</p>
<ol>
<li>如果工作线程数小于核心线程池上限（CorePoolSize），则直接新建一个工作线程并执行任务；</li>
<li>如果工作线程数大于等于CorePoolSize，则尝试将任务加入到队列等待以后执行。如果加入队列失败了（比如队列已满的情况），则在总线程池未满的情况下（<code>CorePoolSize ≤ 工作线程数 ＜ maximumPoolSize</code>）新建一个工作线程立即执行任务，否则执行拒绝策略。</li>
</ol>
<p>添加工作线程addWorker方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">				&#x2F;&#x2F;第一部分，CAS增加工作线程数</span><br><span class="line">        retry:</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int c &#x3D; ctl.get();</span><br><span class="line">            int rs &#x3D; runStateOf(c);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 校验线程池状态，工作队列是否为空等</span><br><span class="line">            if (rs &gt;&#x3D; SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line">						&#x2F;&#x2F;CAS递增线程池数量	</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int wc &#x3D; workerCountOf(c);</span><br><span class="line">                if (wc &gt;&#x3D; CAPACITY ||</span><br><span class="line">                    wc &gt;&#x3D; (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    return false;</span><br><span class="line">                if (compareAndIncrementWorkerCount(c))    &#x2F;&#x2F;更新成功后退出第一部分自旋</span><br><span class="line">                    break retry;</span><br><span class="line">                c &#x3D; ctl.get();  &#x2F;&#x2F; Re-read ctl</span><br><span class="line">                if (runStateOf(c) !&#x3D; rs)</span><br><span class="line">                    continue retry;</span><br><span class="line">                &#x2F;&#x2F; 更新失败就自旋再次重试</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F;第二部分，包装工作线程</span><br><span class="line">        boolean workerStarted &#x3D; false;</span><br><span class="line">        boolean workerAdded &#x3D; false;</span><br><span class="line">        Worker w &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">        		&#x2F;&#x2F;创建好工作线程</span><br><span class="line">            w &#x3D; new Worker(firstTask);</span><br><span class="line">            final Thread t &#x3D; w.thread;</span><br><span class="line">            if (t !&#x3D; null) &#123;</span><br><span class="line">                final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">                &#x2F;&#x2F;加锁，避免加入工作队列时并发</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 锁内再次检查线程池状态</span><br><span class="line">                    int rs &#x3D; runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    if (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123;</span><br><span class="line">                        if (t.isAlive()) &#x2F;&#x2F; precheck that t is startable</span><br><span class="line">                            throw new IllegalThreadStateException();</span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        int s &#x3D; workers.size();</span><br><span class="line">                        if (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize &#x3D; s;</span><br><span class="line">                        workerAdded &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;加入工作线程队列后，启动工作线程</span><br><span class="line">                if (workerAdded) &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        return workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>工作线程执行runWorker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ThreadPoolExecutor.Worker#run</span><br><span class="line">public void run() &#123;</span><br><span class="line">	runWorker(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">        Thread wt &#x3D; Thread.currentThread();</span><br><span class="line">        Runnable task &#x3D; w.firstTask;</span><br><span class="line">        w.firstTask &#x3D; null;</span><br><span class="line">        w.unlock(); &#x2F;&#x2F; allow interrupts</span><br><span class="line">        boolean completedAbruptly &#x3D; true;</span><br><span class="line">        try &#123;</span><br><span class="line">        		&#x2F;&#x2F;自旋从队列中获取任务，getTask比较简单，核心就是从BlockQueue获取任务</span><br><span class="line">            while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                &#x2F;&#x2F; 校验线程池状态，是否中断</span><br><span class="line">                if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F;钩子函数，执行前</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown &#x3D; null;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                        thrown &#x3D; x; throw x;</span><br><span class="line">                    &#125; catch (Error x) &#123;</span><br><span class="line">                        thrown &#x3D; x; throw x;</span><br><span class="line">                    &#125; catch (Throwable x) &#123;</span><br><span class="line">                        thrown &#x3D; x; throw new Error(x);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        &#x2F;&#x2F;钩子函数，执行后</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    task &#x3D; null;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly &#x3D; false;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">        boolean timedOut &#x3D; false; &#x2F;&#x2F; Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int c &#x3D; ctl.get();</span><br><span class="line">            int rs &#x3D; runStateOf(c);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 校验线程池状态，工作队列是否为空</span><br><span class="line">            if (rs &gt;&#x3D; SHUTDOWN &amp;&amp; (rs &gt;&#x3D; STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int wc &#x3D; workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 是否需要超时控制，a)通过设置 b)非核心线程</span><br><span class="line">            boolean timed &#x3D; allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">            if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">                &#x2F;&#x2F;超过最大线程池，需要工作线程减回去</span><br><span class="line">                if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    return null;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">            		&#x2F;&#x2F;核心 从任务队列获取队列方法</span><br><span class="line">                Runnable r &#x3D; timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                if (r !&#x3D; null)</span><br><span class="line">                    return r;</span><br><span class="line">                timedOut &#x3D; true;</span><br><span class="line">            &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">                timedOut &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h5><ul>
<li>AbortPolicy，拒绝报错</li>
<li>DiscardPolicy，丢弃</li>
<li>DiscardOldestPolicy，丢弃最近一个任务，执行当前任务</li>
<li>CallerRunsPolicy，以自身线程来执行</li>
</ul>
<h5 id="线程关闭"><a href="#线程关闭" class="headerlink" title="线程关闭"></a>线程关闭</h5><p>加锁，将线程池状态置为关闭，尝试中断工作线程。shutdownNow类似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void shutdown() &#123;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); &#x2F;&#x2F; hook for ScheduledThreadPoolExecutor</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><blockquote>
<p>拆分合并线程池，是普通线程池的补充，和ThreadPoolExecutor一样，继承自AbstractExecutorService，适合于可拆分子任务的计算密集型任务</p>
</blockquote>
<ul>
<li><p>原理</p>
<ul>
<li><p>基于”分治”算法，相同类型任务拆分，合并成大结果</p>
</li>
<li><p>由于线程处理不同任务速度不同，为了提高效率，采用工作线程”窃取”</p>
</li>
</ul>
</li>
</ul>
<h4 id="使用姿势-9"><a href="#使用姿势-9" class="headerlink" title="使用姿势"></a>使用姿势</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ForkJoinPool executor &#x3D; new ForkJoinPool();</span><br><span class="line">        int[] ints &#x3D; new int[10000];</span><br><span class="line">        Arrays.fill(ints,1);</span><br><span class="line">        ArraySumTask task &#x3D; new ArraySumTask(ints, 0, 9999);</span><br><span class="line"></span><br><span class="line">        ForkJoinTask future &#x3D; executor.submit(task);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; some time passed...</span><br><span class="line"></span><br><span class="line">        if (future.isCompletedAbnormally()) &#123;</span><br><span class="line">            System.out.println(future.getException());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;result: &quot; + future.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class ArraySumTask extends RecursiveTask&lt;Long&gt; &#123;</span><br><span class="line">        private final int[] array;</span><br><span class="line">        private final int begin;</span><br><span class="line">        private final int end;</span><br><span class="line"></span><br><span class="line">        private static final int THRESHOLD &#x3D; 100;</span><br><span class="line"></span><br><span class="line">        public ArraySumTask(int[] array, int begin, int end) &#123;</span><br><span class="line">            this.array &#x3D; array;</span><br><span class="line">            this.begin &#x3D; begin;</span><br><span class="line">            this.end &#x3D; end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected Long compute() &#123;</span><br><span class="line">            long sum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">            if (end - begin + 1 &lt; THRESHOLD) &#123;      &#x2F;&#x2F; 小于阈值, 直接计算</span><br><span class="line">                for (int i &#x3D; begin; i &lt;&#x3D; end; i++) &#123;</span><br><span class="line">                    sum +&#x3D; array[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int middle &#x3D; (end + begin) &#x2F; 2;</span><br><span class="line">                ArraySumTask subtask1 &#x3D; new ArraySumTask(this.array, begin, middle);</span><br><span class="line">                ArraySumTask subtask2 &#x3D; new ArraySumTask(this.array, middle + 1, end);</span><br><span class="line"></span><br><span class="line">                subtask1.fork();</span><br><span class="line">                subtask2.fork();</span><br><span class="line"></span><br><span class="line">                long sum1 &#x3D; subtask1.join();</span><br><span class="line">                long sum2 &#x3D; subtask2.join();</span><br><span class="line"></span><br><span class="line">                sum &#x3D; sum1 + sum2;</span><br><span class="line">            &#125;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">result: 10000</span><br></pre></td></tr></table></figure>

<h4 id="原理小结-9"><a href="#原理小结-9" class="headerlink" title="原理小结"></a>原理小结</h4><h5 id="ForkJoinPool-1"><a href="#ForkJoinPool-1" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h5><p>线程池：接收外部任务提交，接受内部fork任务提交，管理工作队列，任务队列执行；</p>
<ul>
<li><strong>parallelism</strong>：默认值为CPU核心数，ForkJoinPool里工作线程数量与该参数有关，但它不表示最大线程数；</li>
<li><strong>factory</strong>：工作线程工厂，默认是DefaultForkJoinWorkerThreadFactory</li>
<li><strong>handler</strong>：异常处理器；</li>
<li><strong>config</strong>：保存parallelism和mode信息，供后续读取；</li>
<li><strong>ctl</strong>：线程池的核心控制字段</li>
</ul>
<p>mode字段，表示任务队列的处理模式，同步模式=FIFO_QUEUE=先进先出，异步模式=LIFO=后进先出</p>
<h5 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h5><p>线程池调度的任务，是一个Future</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表示没有返回结果的ForkJoin任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveAction</span> <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表示具有返回结果的ForkJoin任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ForkJoinWorkThread"><a href="#ForkJoinWorkThread" class="headerlink" title="ForkJoinWorkThread"></a>ForkJoinWorkThread</h5><p>工作线程，内部包含线程池的引用以及任务队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinWorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool pool;                <span class="comment">// 线程池引用</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool.WorkQueue workQueue; <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ForkJoinWorkerThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"aForkJoinWorkerThread"</span>);        </span><br><span class="line">        <span class="keyword">this</span>.pool = pool;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = pool.registerWorker(<span class="keyword">this</span>);  <span class="comment">//将自己注册到线程池里</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Top-level runloop for workers, called by ForkJoinWorkerThread.run.</span><br><span class="line"> *&#x2F;</span><br><span class="line">final void runWorker(WorkQueue w) &#123;</span><br><span class="line">    w.growArray();                   &#x2F;&#x2F; allocate queue</span><br><span class="line">    int seed &#x3D; w.hint;               &#x2F;&#x2F; initially holds randomization hint</span><br><span class="line">    int r &#x3D; (seed &#x3D;&#x3D; 0) ? 1 : seed;  &#x2F;&#x2F; avoid 0 for xorShift</span><br><span class="line">    for (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">        if ((t &#x3D; scan(w, r)) !&#x3D; null)	   &#x2F;&#x2F;1. 扫描到任务</span><br><span class="line">            w.runTask(t);                &#x2F;&#x2F;2. 执行任务</span><br><span class="line">        else if (!awaitWork(w, r))</span><br><span class="line">            break;</span><br><span class="line">        r ^&#x3D; r &lt;&lt; 13; r ^&#x3D; r &gt;&gt;&gt; 17; r ^&#x3D; r &lt;&lt; 5; &#x2F;&#x2F; xorshift</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h5><p>在线程池ForkJoinPool中维护这一个任务队列，该字段在向线程池提交任务（内部/外部）时会初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class ForkJoinPool extends AbstractExecutorService &#123;</span><br><span class="line">    ...</span><br><span class="line">		volatile WorkQueue[] workQueues; &#x2F;&#x2F; main registry</span><br><span class="line">		...</span><br><span class="line">		</span><br><span class="line">		public &lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task) &#123;</span><br><span class="line">        if (task &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        externalPush(task);</span><br><span class="line">        return task;</span><br><span class="line">    &#125;</span><br><span class="line">    final void externalPush(ForkJoinTask&lt;?&gt; task) &#123;</span><br><span class="line">        WorkQueue[] ws; WorkQueue q; int m;</span><br><span class="line">        ...省略代码...</span><br><span class="line">        externalSubmit(task);</span><br><span class="line">    &#125;</span><br><span class="line">		private void externalSubmit(ForkJoinTask&lt;?&gt; task) &#123;</span><br><span class="line">        ...省略代码...</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            WorkQueue[] ws; WorkQueue q; int rs, m, k;</span><br><span class="line">            boolean move &#x3D; false;</span><br><span class="line">            if ((rs &#x3D; runState) &lt; 0) &#123;</span><br><span class="line">                ...省略代码...</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((rs &amp; STARTED) &#x3D;&#x3D; 0 ||     &#x2F;&#x2F; initialize</span><br><span class="line">                     ((ws &#x3D; workQueues) &#x3D;&#x3D; null || (m &#x3D; ws.length - 1) &lt; 0)) &#123;</span><br><span class="line">                int ns &#x3D; 0;</span><br><span class="line">                rs &#x3D; lockRunState();</span><br><span class="line">                try &#123;</span><br><span class="line">                    if ((rs &amp; STARTED) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        U.compareAndSwapObject(this, STEALCOUNTER, null,</span><br><span class="line">                                               new AtomicLong());</span><br><span class="line">                        &#x2F;&#x2F; create workQueues array with size a power of two</span><br><span class="line">                        int p &#x3D; config &amp; SMASK; &#x2F;&#x2F; ensure at least 2 slots</span><br><span class="line">                        int n &#x3D; (p &gt; 1) ? p - 1 : 1;</span><br><span class="line">                        n |&#x3D; n &gt;&gt;&gt; 1; n |&#x3D; n &gt;&gt;&gt; 2;  n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">                        n |&#x3D; n &gt;&gt;&gt; 8; n |&#x3D; n &gt;&gt;&gt; 16; n &#x3D; (n + 1) &lt;&lt; 1;</span><br><span class="line">                        workQueues &#x3D; new WorkQueue[n];      &#x2F;&#x2F;重点是这里初始化</span><br><span class="line">                        ns &#x3D; STARTED;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    unlockRunState(rs, (rs &amp; ~RSLOCK) | ns);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((q &#x3D; ws[k &#x3D; r &amp; m &amp; SQMASK]) !&#x3D; null) &#123;</span><br><span class="line">               ...省略代码...</span><br><span class="line">            &#125;</span><br><span class="line">            else if (((rs &#x3D; runState) &amp; RSLOCK) &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; create new queue</span><br><span class="line">               ...省略代码...</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                move &#x3D; true;                   &#x2F;&#x2F; move if busy</span><br><span class="line">            if (move)</span><br><span class="line">                r &#x3D; ThreadLocalRandom.advanceProbe(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务队列分为2类，有工作线程绑定的，任务队列下标是<strong>奇数</strong>。没有工作线程绑定的，任务下标是<strong>偶数</strong>（尚未找到代码）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool，绑定工作线程时，下标为奇数</span><br><span class="line">final WorkQueue registerWorker(ForkJoinWorkerThread wt) &#123;</span><br><span class="line">        UncaughtExceptionHandler handler;</span><br><span class="line">        wt.setDaemon(true);                           &#x2F;&#x2F; configure thread</span><br><span class="line">        if ((handler &#x3D; ueh) !&#x3D; null)</span><br><span class="line">            wt.setUncaughtExceptionHandler(handler);</span><br><span class="line">        WorkQueue w &#x3D; new WorkQueue(this, wt);</span><br><span class="line">        int i &#x3D; 0;                                    &#x2F;&#x2F; assign a pool index</span><br><span class="line">        int mode &#x3D; config &amp; MODE_MASK;</span><br><span class="line">        int rs &#x3D; lockRunState();</span><br><span class="line">        try &#123;</span><br><span class="line">            WorkQueue[] ws; int n;                    &#x2F;&#x2F; skip if no array</span><br><span class="line">            if ((ws &#x3D; workQueues) !&#x3D; null &amp;&amp; (n &#x3D; ws.length) &gt; 0) &#123;</span><br><span class="line">                int s &#x3D; indexSeed +&#x3D; SEED_INCREMENT;  &#x2F;&#x2F; unlikely to collide</span><br><span class="line">                int m &#x3D; n - 1;</span><br><span class="line">                i &#x3D; ((s &lt;&lt; 1) | 1) &amp; m;               &#x2F;&#x2F; 任务队列下标</span><br><span class="line">                if (ws[i] !&#x3D; null) &#123;                  &#x2F;&#x2F; collision</span><br><span class="line">                    int probes &#x3D; 0;                   &#x2F;&#x2F; step by approx half n</span><br><span class="line">                    int step &#x3D; (n &lt;&#x3D; 4) ? 2 : ((n &gt;&gt;&gt; 1) &amp; EVENMASK) + 2;</span><br><span class="line">                    while (ws[i &#x3D; (i + step) &amp; m] !&#x3D; null) &#123;</span><br><span class="line">                        if (++probes &gt;&#x3D; n) &#123;</span><br><span class="line">                            workQueues &#x3D; ws &#x3D; Arrays.copyOf(ws, n &lt;&lt;&#x3D; 1);</span><br><span class="line">                            m &#x3D; n - 1;</span><br><span class="line">                            probes &#x3D; 0;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                w.hint &#x3D; s;                           &#x2F;&#x2F; use as random seed</span><br><span class="line">                w.config &#x3D; i | mode;</span><br><span class="line">                w.scanState &#x3D; i;                      &#x2F;&#x2F; publication fence</span><br><span class="line">                ws[i] &#x3D; w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">        &#125;</span><br><span class="line">        wt.setName(workerNamePrefix.concat(Integer.toString(i &gt;&gt;&gt; 1)));</span><br><span class="line">        return w;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><h4 id="使用姿势-10"><a href="#使用姿势-10" class="headerlink" title="使用姿势"></a>使用姿势</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> ScheduledThreadPoolExecutor executor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">3</span>);</span><br><span class="line">        executor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(LocalDateTime.now()+<span class="string">"\t"</span>+Thread.currentThread().getName() + <span class="string">"：我在运行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(LocalDateTime.now()+<span class="string">"\t"</span>+Thread.currentThread().getName() + <span class="string">"：运行结束"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(LocalDateTime.now()+<span class="string">"\t创建线程结束"</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">04</span>-<span class="number">13</span>T18:<span class="number">25</span>:<span class="number">32.293</span>	创建线程结束</span><br><span class="line"><span class="number">2024</span>-<span class="number">04</span>-<span class="number">13</span>T18:<span class="number">25</span>:<span class="number">42.172</span>	pool-<span class="number">1</span>-thread-<span class="number">1</span>：我在运行</span><br><span class="line"><span class="number">2024</span>-<span class="number">04</span>-<span class="number">13</span>T18:<span class="number">25</span>:<span class="number">42.182</span>	pool-<span class="number">1</span>-thread-<span class="number">1</span>：运行结束</span><br></pre></td></tr></table></figure>



<h4 id="原理小结-10"><a href="#原理小结-10" class="headerlink" title="原理小结"></a>原理小结</h4><blockquote>
<p>和ThreadPoolExecutor类似，将Runnable封装成ScheduledFutureTask，阻塞队列用DelayedWorkQueue，内部没有直接继承PriorityBlockingQueue，自己实现了优先级队列，因为线程池调度会利用阻塞队列的take。因此天然等待最早到时间的线程。</p>
</blockquote>
<h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>类继承关系</p>
<p><img src="/2024/04/13/5_Java%E5%9F%BA%E7%A1%80/6.png" alt loading="lazy"></p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><blockquote>
<p>解释表头，第一列表示相关类型的操作（入队，出队，检索队头元素），第一行表示当相关操作第一时间不符合条件（如队头队尾无元素）时触发的操作（如抛异常，返回特定值，阻塞，超时阻塞）</p>
</blockquote>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul>
<li>Queue</li>
</ul>
<blockquote>
<p>普通队列</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>Throws exception</th>
<th>Returns special value</th>
</tr>
</thead>
<tbody><tr>
<td>Insert</td>
<td>add(e)</td>
<td>offer(e)</td>
</tr>
<tr>
<td>Remove</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>Examine</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody></table>
<ul>
<li>BlockingQueue</li>
</ul>
<blockquote>
<p>阻塞队列</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>Throws exception</th>
<th>special value</th>
<th>Blocks</th>
<th>Times out</th>
</tr>
</thead>
<tbody><tr>
<td>Insert</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>Remove</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>Examine</td>
<td>element()</td>
<td>peek()</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>Dueue</li>
</ul>
<blockquote>
<p>双端队列</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>First Element (Head)</th>
<th>First Element (Head)</th>
<th>Last Element (Tail)</th>
<th>Last Element (Tail)</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Throws exception</td>
<td>Special value</td>
<td>Throws exception</td>
<td>Special value</td>
</tr>
<tr>
<td>Insert</td>
<td>addFirst(e)</td>
<td>offerFirst(e)</td>
<td>addLast(e)</td>
<td>offerLast(e)</td>
</tr>
<tr>
<td>Remove</td>
<td>remove()</td>
<td>poll()</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>Examine</td>
<td>element()</td>
<td>peek()</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<ul>
<li>BlockingDeque</li>
</ul>
<blockquote>
<p>阻塞双端队列</p>
</blockquote>
<p>First Element (Head)</p>
<table>
<thead>
<tr>
<th></th>
<th>Throws exception</th>
<th>Special value</th>
<th>Blocks</th>
<th>Times out</th>
</tr>
</thead>
<tbody><tr>
<td>Insert</td>
<td>addFirst(e)</td>
<td>offerFirst(e)</td>
<td>putFirst(e)</td>
<td>offerFirst(e, time, unit)</td>
</tr>
<tr>
<td>Remove</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
<td>takeFirst()</td>
<td>pollFirst(time, unit)</td>
</tr>
<tr>
<td>Examine</td>
<td>getFirst()</td>
<td>peekFirst()</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Last Element (Tail)，与上面类似</p>
<table>
<thead>
<tr>
<th></th>
<th>Throws exception</th>
<th>Special value</th>
<th>Blocks</th>
<th>Times out</th>
</tr>
</thead>
<tbody><tr>
<td>Insert</td>
<td>addLast(e)</td>
<td>offerLast(e)</td>
<td>putLast(e)</td>
<td>offerLast(e, time, unit)</td>
</tr>
<tr>
<td>Remove</td>
<td>removeLast()</td>
<td>pollLast()</td>
<td>takeLast()</td>
<td>pollLast(time, unit)</td>
</tr>
<tr>
<td>Examine</td>
<td>getLast()</td>
<td>peekLast()</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>TransferQueue</li>
</ul>
<blockquote>
<p>传输队列，是一种特殊的阻塞队列，发送放会等待消费方检索数据</p>
</blockquote>
<p>主要方法：</p>
<p>tryTransfer(E e) 和tryTransfer(E e, long timeout, TimeUnit unit)尝试传输，当没有对象时，返回false</p>
<p>transfer(E e)是阻塞传输，一直等待消费</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>ConcurrentLinkedQueue</li>
</ul>
<blockquote>
<p>1.5版本</p>
</blockquote>
<p>利用链表存储，基于自旋和CAS实现入队出队</p>
<ul>
<li>ArrayBlockingQueue</li>
</ul>
<blockquote>
<p>1.5版本</p>
</blockquote>
<p>利用数组存储，环形入队出队，使用ReentrantLock实现线程安全，两个条件变量notFull和notEmpty，当队满时，put方法在<strong>notFull</strong>上等待，当队没有元素时，take方法在<strong>notEmpty</strong>上等待。</p>
<ul>
<li>LinkedBlockingQueue</li>
</ul>
<blockquote>
<p>1.5版本</p>
</blockquote>
<p>利用链表存储，入队和出队采用两个RentrantLock锁，同时用AtomicInteger存储队列元素个数。不支持公平非公平</p>
<ul>
<li>PriorityBlockingQueue</li>
</ul>
<blockquote>
<p>1.5版本</p>
</blockquote>
<p>利用数组存储，无界，最大/最小堆实现优先级。利用RentrantLock加锁，只有出队take有条件变量<strong>notEmpty</strong> 等待</p>
<ul>
<li>SynchronousQueue</li>
</ul>
<blockquote>
<p>1.5版本</p>
</blockquote>
<p>利用栈或队列结构的节点对象，存放入队等待的节点，当出队线程加入后，弹出匹配的节点线程，并交换数据</p>
<ul>
<li>DelayQueue</li>
</ul>
<blockquote>
<p>1.5版本</p>
</blockquote>
<p>利用PriorityBlockingQueue存放元素，利用ReentrantLock加锁，入队不等待，出队等待。当时间没到时，等待【剩余时间】</p>
<ul>
<li>LinkedBlockingDeque</li>
</ul>
<blockquote>
<p>1.6版本</p>
</blockquote>
<p>利用链表存储，双端入队出队共用一把ReentrantLock锁，双端队列用来实现【工作窃取】</p>
<ul>
<li>ConcurrentLinkedDeque</li>
</ul>
<blockquote>
<p>1.7版本</p>
</blockquote>
<p>利用链表存储，采用自旋和CAS实现【无锁】，逻辑简单，实现比较复杂</p>
<ul>
<li>LinkedTransferQueue</li>
</ul>
<blockquote>
<p>1.7版本</p>
</blockquote>
<p>继承了SynchronousQueue的功能，由于继承了tryTransfer，可以实现异步入队，不用等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">LinkedTransferQueue&lt;Integer&gt; arrayBlockingQueue = <span class="keyword">new</span> LinkedTransferQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">if</span>(finalI ==<span class="number">0</span>)&#123;</span><br><span class="line">                Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Integer poll = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            poll = arrayBlockingQueue.take();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">"消费"</span>+poll);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"consumer"</span> + i);</span><br><span class="line">                t1.start();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">boolean</span> b = arrayBlockingQueue.tryTransfer(finalI);</span><br><span class="line">                        System.out.println(finalI + <span class="string">"\t"</span> + b);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"producer"</span> + i);</span><br><span class="line">                t1.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">2</span>	<span class="keyword">false</span></span><br><span class="line"><span class="number">4</span>	<span class="keyword">false</span></span><br><span class="line"><span class="number">1</span>	<span class="keyword">true</span></span><br><span class="line">消费<span class="number">1</span></span><br><span class="line"><span class="number">3</span>	<span class="keyword">false</span></span><br></pre></td></tr></table></figure>



<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h4><ul>
<li>Set</li>
</ul>
<blockquote>
<p>不解释，无重复元素集合</p>
</blockquote>
<ul>
<li>SortedSet</li>
</ul>
<blockquote>
<p>有序的无重复元素集合</p>
</blockquote>
<ul>
<li>NavigableSet</li>
</ul>
<blockquote>
<p>提供定位检索方法的SortedSet，例如比某个元素大，小，移除最小，最大，降序升序等方法</p>
</blockquote>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><ul>
<li>CopyOnWriteArraySet</li>
</ul>
<blockquote>
<p>1.5版本</p>
</blockquote>
<p>直接内部代理CopyOnWriteArrayList，实现并发操作</p>
<ul>
<li>ConcurrentSkipListSet</li>
</ul>
<blockquote>
<p>1.6版本</p>
</blockquote>
<p>直接内部代理ConcurrentNavigableMap，实现并发操作</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="接口-2"><a href="#接口-2" class="headerlink" title="接口"></a>接口</h4><ul>
<li>Map</li>
</ul>
<blockquote>
<p>不解释，字典</p>
</blockquote>
<ul>
<li>SortedMap</li>
</ul>
<blockquote>
<p>有序的无重复Key的字典，根据Key排序</p>
</blockquote>
<ul>
<li>NavigableMap</li>
</ul>
<blockquote>
<p>提供定位检索方法的SortedMap，和NavigableSet类似，只不过根据Key进行定位</p>
</blockquote>
<ul>
<li>ConcurrentMap</li>
</ul>
<blockquote>
<p>提供并发安全操作的能力</p>
</blockquote>
<ul>
<li>ConcurrentNavigableMap</li>
</ul>
<blockquote>
<p>提供支持定位检索方法的并发安全操作的能力</p>
</blockquote>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><ul>
<li>ConcurrentHashMap</li>
</ul>
<blockquote>
<p>1.5版本</p>
</blockquote>
<p>高频面试点，底层和TreeMap类似，put时，采用CAS插入Key，当node冲突后，利用node对象锁（synchroized）加入冲突链表</p>
<ul>
<li>ConcurrentSkipListMap</li>
</ul>
<blockquote>
<p>1.6版本</p>
</blockquote>
<p>为了高效检索，利用多层二级索引实现跳表，自旋和CAS并发操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Head nodes          Index nodes                                          </span><br><span class="line">+-+    right        +-+                      +-+                         </span><br><span class="line">|2|----------------&gt;| |---------------------&gt;| |-&gt;null                   </span><br><span class="line">+-+                 +-+                      +-+                         </span><br><span class="line"> | down              |                        |                          </span><br><span class="line"> v                   v                        v                          </span><br><span class="line">+-+            +-+  +-+       +-+            +-+       +-+               </span><br><span class="line">|1|-----------&gt;| |-&gt;| |------&gt;| |-----------&gt;| |------&gt;| |-&gt;null         </span><br><span class="line">+-+            +-+  +-+       +-+            +-+       +-+               </span><br><span class="line"> v              |    |         |              |         |                </span><br><span class="line">Nodes  next     v    v         v              v         v                </span><br><span class="line">+-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+               </span><br><span class="line">| |-&gt;|A|-&gt;|B|-&gt;|C|-&gt;|D|-&gt;|E|-&gt;|F|-&gt;|G|-&gt;|H|-&gt;|I|-&gt;|J|-&gt;|K|-&gt;null         </span><br><span class="line">+-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+</span><br></pre></td></tr></table></figure>



<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="接口-3"><a href="#接口-3" class="headerlink" title="接口"></a>接口</h4><ul>
<li>List</li>
</ul>
<blockquote>
<p>不解释，链表</p>
</blockquote>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><ul>
<li>CopyOnWriteArrayList</li>
</ul>
<blockquote>
<p>1.5版本</p>
</blockquote>
<p>利用数组存储，写时复制，读取的时候可以不用加锁，适合于”读多写少的场景”，占用内存较多</p>
<h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>基于CAS为了实现无锁算法，AtomicInteger，AtomicReference，AtomicXXXFieldUpdater。1.8提供了LongAdder，利用分段的思想，分散热点</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>TODO</p>

                    
                </div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                    </div>
                    <div>
                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/2024/04/18/%E5%90%84%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%89%8D%E6%B2%BF%E7%89%88%E6%9C%AC/"
                                   title="各类组件前沿版本"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">各类组件前沿版本</span>
                                        <span class="post-nav-item">上一篇</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/2024/03/11/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"
                                   title="课程学习"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">课程学习</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    






                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E5%86%85%E5%AD%98%E5%8C%BA"><span class="nav-text">运行内存区</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="nav-text">类加载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JMM"><span class="nav-text">JMM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E8%A7%84%E8%8C%83"><span class="nav-text">结构规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E4%B8%AA%E7%89%B9%E6%80%A7"><span class="nav-text">三个特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5"><span class="nav-text">常用概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Volatile"><span class="nav-text">Volatile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86"><span class="nav-text">硬件原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-text">常见问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-text">相关知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-text">垃圾收集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95"><span class="nav-text">三色标记法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%A1%E8%A1%A8"><span class="nav-text">卡表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="nav-text">写屏障</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">经典收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMS"><span class="nav-text">CMS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#G1"><span class="nav-text">G1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">其他收集器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Synchronized"><span class="nav-text">Synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MarkWord"><span class="nav-text">MarkWord</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-1"><span class="nav-text">常见问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JUC"><span class="nav-text">JUC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS"><span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-text">特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E9%94%81%EF%BC%88Lock%EF%BC%89"><span class="nav-text">基础锁（Lock）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock"><span class="nav-text">ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93"><span class="nav-text">原理小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantReadWriteLock"><span class="nav-text">ReentrantReadWriteLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-1"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-1"><span class="nav-text">原理小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StampedLock"><span class="nav-text">StampedLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-2"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-2"><span class="nav-text">原理小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-2"><span class="nav-text">常见问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94"><span class="nav-text">简单对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7"><span class="nav-text">同步工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore"><span class="nav-text">Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-3"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-3"><span class="nav-text">原理小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch"><span class="nav-text">CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-4"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-4"><span class="nav-text">原理小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier"><span class="nav-text">CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-5"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-5"><span class="nav-text">原理小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exchanger"><span class="nav-text">Exchanger</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-6"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-6"><span class="nav-text">原理小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Phaser"><span class="nav-text">Phaser</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-7"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-7"><span class="nav-text">原理小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94-1"><span class="nav-text">简单对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-text">ThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-8"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-8"><span class="nav-text">原理小结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-text">线程池构造器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="nav-text">线程池状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C"><span class="nav-text">线程执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-text">拒绝策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%B3%E9%97%AD"><span class="nav-text">线程关闭</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ForkJoinPool"><span class="nav-text">ForkJoinPool</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-9"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-9"><span class="nav-text">原理小结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ForkJoinPool-1"><span class="nav-text">ForkJoinPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ForkJoinTask"><span class="nav-text">ForkJoinTask</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ForkJoinWorkThread"><span class="nav-text">ForkJoinWorkThread</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WorkQueue"><span class="nav-text">WorkQueue</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScheduledThreadPoolExecutor"><span class="nav-text">ScheduledThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-10"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-10"><span class="nav-text">原理小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="nav-text">并发容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue"><span class="nav-text">Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-text">接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3-1"><span class="nav-text">接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3-2"><span class="nav-text">接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3-3"><span class="nav-text">接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="nav-text">实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-text">原子类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-text">其他</span></a></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="copyright-info info-item">
        &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2024
        
            &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">EmiyaQ</a>
        
    </div>

    <div class="theme-info info-item">
        由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
    </div>

    

    

    
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="post-tools-list border-box">
        <!-- PC encrypt again -->
        

        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <!-- toggle mode -->
        
            <li class="tools-item tool-toggle-theme-mode flex-center">
                <i class="fas fa-moon"></i>
            </li>
        

        <!-- rss -->
        

        <!-- to bottom -->
        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E5%86%85%E5%AD%98%E5%8C%BA"><span class="nav-text">运行内存区</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="nav-text">类加载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JMM"><span class="nav-text">JMM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E8%A7%84%E8%8C%83"><span class="nav-text">结构规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E4%B8%AA%E7%89%B9%E6%80%A7"><span class="nav-text">三个特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5"><span class="nav-text">常用概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Volatile"><span class="nav-text">Volatile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86"><span class="nav-text">硬件原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-text">常见问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-text">相关知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-text">垃圾收集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95"><span class="nav-text">三色标记法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%A1%E8%A1%A8"><span class="nav-text">卡表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="nav-text">写屏障</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">经典收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMS"><span class="nav-text">CMS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#G1"><span class="nav-text">G1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">其他收集器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Synchronized"><span class="nav-text">Synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MarkWord"><span class="nav-text">MarkWord</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-1"><span class="nav-text">常见问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JUC"><span class="nav-text">JUC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS"><span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-text">特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E9%94%81%EF%BC%88Lock%EF%BC%89"><span class="nav-text">基础锁（Lock）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock"><span class="nav-text">ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93"><span class="nav-text">原理小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantReadWriteLock"><span class="nav-text">ReentrantReadWriteLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-1"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-1"><span class="nav-text">原理小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StampedLock"><span class="nav-text">StampedLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-2"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-2"><span class="nav-text">原理小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-2"><span class="nav-text">常见问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94"><span class="nav-text">简单对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7"><span class="nav-text">同步工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore"><span class="nav-text">Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-3"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-3"><span class="nav-text">原理小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch"><span class="nav-text">CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-4"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-4"><span class="nav-text">原理小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier"><span class="nav-text">CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-5"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-5"><span class="nav-text">原理小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exchanger"><span class="nav-text">Exchanger</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-6"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-6"><span class="nav-text">原理小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Phaser"><span class="nav-text">Phaser</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-7"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-7"><span class="nav-text">原理小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94-1"><span class="nav-text">简单对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-text">ThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-8"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-8"><span class="nav-text">原理小结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-text">线程池构造器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="nav-text">线程池状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C"><span class="nav-text">线程执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-text">拒绝策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%B3%E9%97%AD"><span class="nav-text">线程关闭</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ForkJoinPool"><span class="nav-text">ForkJoinPool</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-9"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-9"><span class="nav-text">原理小结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ForkJoinPool-1"><span class="nav-text">ForkJoinPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ForkJoinTask"><span class="nav-text">ForkJoinTask</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ForkJoinWorkThread"><span class="nav-text">ForkJoinWorkThread</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WorkQueue"><span class="nav-text">WorkQueue</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScheduledThreadPoolExecutor"><span class="nav-text">ScheduledThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF-10"><span class="nav-text">使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93-10"><span class="nav-text">原理小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="nav-text">并发容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue"><span class="nav-text">Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-text">接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3-1"><span class="nav-text">接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3-2"><span class="nav-text">接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3-3"><span class="nav-text">接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="nav-text">实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-text">原子类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-text">其他</span></a></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>





<!-- common js -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local search -->

    
<script src="/js/local-search.js"></script>



<!-- lazyload -->

    
<script src="/js/lazyload.js"></script>



<div class="">
    <!-- home page -->
    

    <!-- post page -->
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        
            
<script src="/js/post/toc.js"></script>

        

        <!-- copyright-info -->
        

        <!-- share -->
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->



</body>
</html>
