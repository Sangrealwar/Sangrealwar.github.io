<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="人生，总有些黑暗的隧道需要自己穿越">
    <meta name="author" content="EmiyaQ">
    
    <title>
        
            Kudu源码阅读 |
        
        The winter sunshine
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.svg">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"The winter sunshine","author":"EmiyaQ","avatar":"/images/pig.png","logo":"/images/logo.svg","favicon":"/images/logo.svg"},"menu":{"home":"/","categories":"/categories"},"first_screen":{"enable":false,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"Keep writing and Keep loving.","hitokoto":false},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":false,"hide_header":true},"home":{"announcement":null,"category":true,"tag":true,"post_datetime":"updated"},"post":{"author_badge":{"enable":false,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":false,"min2read":false},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":false,"share":false,"reward":{"enable":false,"img_link":null,"text":null,"icon":null}},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"toc":{"enable":true,"number":false,"expand_all":false,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":false,"site_uv":false,"site_pv":false,"page_pv":false}},"local_search":{"enable":true,"preload":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.36"},"waline":{"server_url":null,"reaction":false,"version":"3.2.1"},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":true},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":true},"footer":{"since":2020,"word_count":false,"site_deploy":{"enable":false,"provider":"github","url":null},"record":{"enable":false,"list":[{"code":null,"link":null}]}},"inject":{"enable":false,"css":[null],"js":[null]},"root":"","source_data":{},"version":"4.2.3"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left flex-start border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               The winter sunshine
            </a>
        </div>

        <div class="right border-box">
            <div class="pc border-box">
                <ul class="menu-list border-box">
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/">
                                
                                首页
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/categories">
                                
                                分类
                                
                            </a>
                            
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="menu-text-color fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile border-box flex-start">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list border-box">
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/">
                            
                            首页
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/categories">
                            
                            分类
                        </a>
                        
                    </label>
                    
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        Kudu源码阅读
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/pig.png">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">EmiyaQ</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2024-02-24 14:28:55</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Sun Aug 04 2024 23:34:25 GMT+0800">2024-08-04 23:34:25</span>
            </span>
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/">分布式组件</a></li>
                        
                    
                </ul>
            </span>
        

        

        
        
        
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body ">
                    

                    
                         <p>Kudu读取过程</p>
<ol>
<li>Tablet的rowset结构</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct TabletComponents : public RefCountedThreadSafe&lt;TabletComponents&gt; &#123;</span><br><span class="line">  TabletComponents(std::shared_ptr&lt;MemRowSet&gt; mrs,</span><br><span class="line">                   std::vector&lt;std::shared_ptr&lt;MemRowSet&gt;&gt; txn_mrss,</span><br><span class="line">                   std::shared_ptr&lt;RowSetTree&gt; rs_tree);</span><br><span class="line">  &#x2F;&#x2F; The &quot;main&quot; MemRowSet that catches inserts to the tablet that are not a</span><br><span class="line">  &#x2F;&#x2F; part of any transaction.</span><br><span class="line">  const std::shared_ptr&lt;MemRowSet&gt; memrowset;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; MemRowSets whose insertion heads were inserted as a part of a transaction.</span><br><span class="line">  const std::vector&lt;std::shared_ptr&lt;MemRowSet&gt;&gt; txn_memrowsets;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The persisted RowSets that comprise the rows of a tablet.</span><br><span class="line">  const std::shared_ptr&lt;RowSetTree&gt; rowsets;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>主要类结构图</li>
</ol>
<p><img src="/2024/02/24/3_Kudu%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/1.png" alt="image-202306" loading="lazy"></p>
<ol start="3">
<li>代码流程</li>
</ol>
<p>C++暴露的Scan接口，由JavaClient的org.apache.kudu.client.AsyncKuduClient#sendRpcToTablet发出RPC请求，扫描数据，kudu服务器接受请求的是kudu.tserver.TabletServerService的Scan（中间经过RPC层中转）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">org.apache.kudu.client.AsyncKuduScanner#nextRows</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Deferred&lt;RowResultIterator&gt; <span class="title">nextRows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;  <span class="comment">// We're already done scanning.</span></span><br><span class="line">      <span class="keyword">if</span> (prefetching &amp;&amp; cachedPrefetcherDeferred.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// return the cached result and reset the cache.</span></span><br><span class="line">        <span class="keyword">return</span> cachedPrefetcherDeferred.getAndUpdate((v) -&gt; <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Deferred.fromResult(<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tablet == <span class="keyword">null</span>) &#123;</span><br><span class="line">      Callback&lt;Deferred&lt;RowResultIterator&gt;, AsyncKuduScanner.Response&gt; cb =</span><br><span class="line">          <span class="keyword">new</span> Callback&lt;Deferred&lt;RowResultIterator&gt;, Response&gt;() &#123;</span><br><span class="line">         ...</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      Callback&lt;Deferred&lt;RowResultIterator&gt;, Exception&gt; eb =</span><br><span class="line">          <span class="keyword">new</span> Callback&lt;Deferred&lt;RowResultIterator&gt;, Exception&gt;() &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 发起请求</span></span><br><span class="line">      <span class="keyword">return</span> client.sendRpcToTablet(getOpenRequest()).addCallbackDeferring(cb).addErrback(eb);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prefetching &amp;&amp; cachedPrefetcherDeferred.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Deferred&lt;RowResultIterator&gt; d =</span><br><span class="line">        client.scanNextRows(<span class="keyword">this</span>).addCallbacks(gotNextRow, nextRowErrback());</span><br><span class="line">    <span class="keyword">if</span> (prefetching) &#123;</span><br><span class="line">      d.chain(<span class="keyword">new</span> Deferred&lt;RowResultIterator&gt;().addCallback(prefetch));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>KuduServer（C++），1.17版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TabletServiceImpl::Scan</span><span class="params">(<span class="keyword">const</span> ScanRequestPB* req,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ScanResponsePB* resp,</span></span></span><br><span class="line"><span class="function"><span class="params">                             RpcContext* context)</span> </span>&#123;</span><br><span class="line">  TRACE_EVENT0(<span class="string">"tserver"</span>, <span class="string">"TabletServiceImpl::Scan"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// check 第一次读取数据，或者第二次读取</span></span><br><span class="line">  <span class="keyword">if</span> (PREDICT_FALSE(req-&gt;has_scanner_id() &amp;&amp;</span><br><span class="line">                    req-&gt;has_new_scan_request())) &#123;</span><br><span class="line">    context-&gt;RespondFailure(Status::InvalidArgument(</span><br><span class="line">                            <span class="string">"Must not pass both a scanner_id and new_scan_request"</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 验证是否有权限</span></span><br><span class="line">  TokenPB token;</span><br><span class="line">  <span class="keyword">if</span> (FLAGS_tserver_enforce_access_control &amp;&amp; req-&gt;has_new_scan_request()) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; scan_pb = req-&gt;new_scan_request();</span><br><span class="line">    <span class="keyword">if</span> (!VerifyAuthzTokenOrRespond(server_-&gt;token_verifier(),</span><br><span class="line">                                   req-&gt;new_scan_request(), context, &amp;token)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    scoped_refptr&lt;TabletReplica&gt; replica;</span><br><span class="line">    <span class="keyword">if</span> (!LookupRunningTabletReplicaOrRespond(server_-&gt;tablet_manager(),</span><br><span class="line">        req-&gt;new_scan_request().tablet_id(), resp, context, &amp;replica)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; privilege = token.authz().table_privilege();</span><br><span class="line">    <span class="keyword">if</span> (!CheckMatchingTableIdOrRespond(privilege, replica-&gt;tablet_metadata()-&gt;table_id(),</span><br><span class="line">                                       <span class="string">"Scan"</span>, context)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;ColumnId&gt; authorized_column_ids;</span><br><span class="line">    <span class="keyword">if</span> (!CheckMayHaveScanPrivilegesOrRespond(privilege, <span class="string">"Scan"</span>, &amp;authorized_column_ids, context)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If the token doesn't have full scan privileges for the table, check</span></span><br><span class="line">    <span class="comment">// for required privileges based on the scan request.</span></span><br><span class="line">    <span class="keyword">if</span> (!privilege.scan_privilege()) &#123;</span><br><span class="line">      <span class="keyword">const</span> SchemaPtr schema_ptr = replica-&gt;tablet_metadata()-&gt;schema();</span><br><span class="line">      <span class="keyword">if</span> (!CheckScanPrivilegesOrRespond(scan_pb, *schema_ptr, authorized_column_ids,</span><br><span class="line">                                        <span class="string">"Scan"</span>, context)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//开始读数据</span></span><br><span class="line">  <span class="function">ScanResultCopier <span class="title">collector</span><span class="params">(GetMaxBatchSizeBytesHint(req))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> has_more_results = <span class="literal">false</span>;</span><br><span class="line">  TabletServerErrorPB::Code error_code = TabletServerErrorPB::UNKNOWN_ERROR;</span><br><span class="line">  <span class="keyword">if</span> (req-&gt;has_new_scan_request()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!CheckTabletServerNotQuiescingOrRespond(server_, resp, context)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> NewScanRequestPB&amp; scan_pb = req-&gt;new_scan_request();</span><br><span class="line">    scoped_refptr&lt;TabletReplica&gt; replica;</span><br><span class="line">    <span class="keyword">if</span> (!LookupRunningTabletReplicaOrRespond(server_-&gt;tablet_manager(), scan_pb.tablet_id(), resp,</span><br><span class="line">                                             context, &amp;replica)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> scanner_id;</span><br><span class="line">    Timestamp scan_timestamp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始读取数据，并记录scanner_id</span></span><br><span class="line">    Status s = HandleNewScanRequest(replica.<span class="built_in">get</span>(), req, context,</span><br><span class="line">                                    &amp;collector, &amp;scanner_id, &amp;scan_timestamp, &amp;has_more_results,</span><br><span class="line">                                    &amp;error_code);</span><br><span class="line">    <span class="keyword">if</span> (PREDICT_FALSE(!s.ok())) &#123;</span><br><span class="line">      SetupErrorAndRespond(resp-&gt;mutable_error(), s, error_code, context);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only set the scanner id if we have more results.</span></span><br><span class="line">    <span class="keyword">if</span> (has_more_results) &#123;</span><br><span class="line">      resp-&gt;set_scanner_id(scanner_id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (scan_timestamp != Timestamp::kInvalidTimestamp) &#123;</span><br><span class="line">      resp-&gt;set_snap_timestamp(scan_timestamp.ToUint64());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req-&gt;has_scanner_id()) &#123;</span><br><span class="line">    <span class="comment">//继续读取数据</span></span><br><span class="line">    Status s = HandleContinueScanRequest(req, context, &amp;collector, &amp;has_more_results, &amp;error_code);</span><br><span class="line">    <span class="keyword">if</span> (PREDICT_FALSE(!s.ok())) &#123;</span><br><span class="line">      SetupErrorAndRespond(resp-&gt;mutable_error(), s, error_code, context);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    context-&gt;RespondFailure(Status::InvalidArgument(</span><br><span class="line">                              <span class="string">"Must pass either a scanner_id or new_scan_request"</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  collector.SetupResponse(context, resp);</span><br><span class="line">  resp-&gt;set_has_more_results(has_more_results);</span><br><span class="line">  resp-&gt;set_propagated_timestamp(server_-&gt;clock()-&gt;Now().ToUint64());</span><br><span class="line"></span><br><span class="line">  SetResourceMetrics(context, collector.cpu_times(), resp-&gt;mutable_resource_metrics());</span><br><span class="line">  context-&gt;RespondSuccess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次读取</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TabletServiceImpl::HandleNewScanRequest</span><span class="params">(TabletReplica* replica,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">const</span> ScanRequestPB* req,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">const</span> RpcContext* rpc_context,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               ScanResultCollector* result_collector,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="built_in">string</span>* scanner_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               Timestamp* snap_timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">bool</span>* has_more_results,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               TabletServerErrorPB::Code* error_code)</span> </span>&#123;</span><br><span class="line">  ... 省略了一波操作</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//初始化RowwiseIterator迭代器</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;RowwiseIterator&gt; iter;</span><br><span class="line">  optional&lt;Timestamp&gt; snap_start_timestamp;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    TRACE(<span class="string">"Creating iterator"</span>);</span><br><span class="line">    TRACE_EVENT0(<span class="string">"tserver"</span>, <span class="string">"Create iterator"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (scan_pb.read_mode()) &#123;</span><br><span class="line">      <span class="keyword">case</span> UNKNOWN_READ_MODE: &#123;</span><br><span class="line">        *error_code = TabletServerErrorPB::INVALID_SCAN_SPEC;</span><br><span class="line">        <span class="keyword">return</span> Status::NotSupported(<span class="string">"Unknown read mode."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> READ_LATEST: &#123;</span><br><span class="line">        <span class="keyword">if</span> (scan_pb.has_snap_start_timestamp()) &#123;</span><br><span class="line">          *error_code = TabletServerErrorPB::INVALID_SCAN_SPEC;</span><br><span class="line">          <span class="keyword">return</span> Status::InvalidArgument(<span class="string">"scan start timestamp is only supported "</span></span><br><span class="line">                                         <span class="string">"in READ_AT_SNAPSHOT read mode"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过tablet初始化RowIterator器</span></span><br><span class="line">        s = tablet-&gt;NewRowIterator(projection, &amp;iter);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> READ_YOUR_WRITES: <span class="comment">// Fallthrough intended</span></span><br><span class="line">      <span class="keyword">case</span> READ_AT_SNAPSHOT: &#123;</span><br><span class="line">        s = HandleScanAtSnapshot(</span><br><span class="line">            scan_pb, rpc_context, projection, tablet.<span class="built_in">get</span>(), replica-&gt;time_manager(),</span><br><span class="line">            &amp;iter, &amp;snap_start_timestamp, snap_timestamp, error_code);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TRACE(<span class="string">"Iterator created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//省略一堆</span></span><br><span class="line">	 </span><br><span class="line">  scanner-&gt;Init(<span class="built_in">std</span>::<span class="built_in">move</span>(iter), <span class="built_in">std</span>::<span class="built_in">move</span>(orig_spec), <span class="built_in">std</span>::<span class="built_in">move</span>(client_projection));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stop the scanner timer because ContinueScanRequest starts its own timer.</span></span><br><span class="line">  scanner_timer.Stop();</span><br><span class="line">  unreg_scanner.Cancel();</span><br><span class="line">  *scanner_id = scanner-&gt;id();</span><br><span class="line"></span><br><span class="line">  VLOG(<span class="number">1</span>) &lt;&lt; <span class="string">"Started scanner "</span> &lt;&lt; scanner-&gt;id() &lt;&lt; <span class="string">": "</span> &lt;&lt; scanner-&gt;iter()-&gt;ToString();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (GetMaxBatchSizeBytesHint(req) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    TRACE(<span class="string">"Continuing scan request"</span>);</span><br><span class="line">    <span class="comment">// TODO(wdberkeley): Instead of copying the pb, instead split</span></span><br><span class="line">    <span class="comment">// HandleContinueScanRequest and call the second half directly. Once that's</span></span><br><span class="line">    <span class="comment">// done, remove the call to ScopedAddScannerTiming::Stop() above (and the</span></span><br><span class="line">    <span class="comment">// method as it won't be used) and start the timing for continue requests</span></span><br><span class="line">    <span class="comment">// from the first half that is no longer executed in this codepath.</span></span><br><span class="line">    <span class="function">ScanRequestPB <span class="title">continue_req</span><span class="params">(*req)</span></span>;</span><br><span class="line">    continue_req.set_scanner_id(scanner-&gt;id());</span><br><span class="line">    scanner_lock.Unlock();</span><br><span class="line">    <span class="comment">//初始化好了scanRequest，开始扫描</span></span><br><span class="line">    <span class="keyword">return</span> HandleContinueScanRequest(</span><br><span class="line">        &amp;continue_req, rpc_context, result_collector, has_more_results, error_code);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Increment the scanner call sequence ID. HandleContinueScanRequest handles</span></span><br><span class="line">  <span class="comment">// this in the non-empty scan case.</span></span><br><span class="line">  scanner-&gt;IncrementCallSeqId();</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是读取历史的，和上面代码类似</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TabletServiceImpl::HandleContinueScanRequest</span><span class="params">(<span class="keyword">const</span> ScanRequestPB* req,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">const</span> RpcContext* rpc_context,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    ScanResultCollector* result_collector,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">bool</span>* has_more_results,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    TabletServerErrorPB::Code* error_code)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//省略</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获取scan</span></span><br><span class="line">  <span class="keyword">size_t</span> batch_size_bytes = GetMaxBatchSizeBytesHint(req);</span><br><span class="line"></span><br><span class="line">  SharedScanner scanner;</span><br><span class="line">  TabletServerErrorPB::Code code = TabletServerErrorPB::UNKNOWN_ERROR;</span><br><span class="line">  Status s = server_-&gt;scanner_manager()-&gt;LookupScanner(req-&gt;scanner_id(),</span><br><span class="line">                                                       rpc_context-&gt;remote_user().username(),</span><br><span class="line">                                                       &amp;code,</span><br><span class="line">                                                       &amp;scanner);</span><br><span class="line">  <span class="comment">//省略</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获取迭代读取器</span></span><br><span class="line">  RowwiseIterator* iter = scanner-&gt;iter();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the row format flags on the ScanResultCollector.</span></span><br><span class="line">  s = result_collector-&gt;InitSerializer(scanner-&gt;row_format_flags(),</span><br><span class="line">                                       iter-&gt;schema(),</span><br><span class="line">                                       *scanner-&gt;client_projection_schema());</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    *error_code = TabletServerErrorPB::INVALID_SCAN_SPEC;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(todd): could size the RowBlock based on the user's requested batch size?</span></span><br><span class="line">  <span class="comment">// If people had really large indirect objects, we would currently overshoot</span></span><br><span class="line">  <span class="comment">// their requested batch size by a lot.</span></span><br><span class="line">  <span class="function">RowBlockMemory <span class="title">mem</span><span class="params">(<span class="number">32</span> * <span class="number">1024</span>)</span></span>;</span><br><span class="line">  <span class="function">RowBlock <span class="title">block</span><span class="params">(&amp;iter-&gt;schema(), FLAGS_scanner_batch_size_rows, &amp;mem)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(todd): in the future, use the client timeout to set a budget. For now,</span></span><br><span class="line">  <span class="comment">// just use a half second, which should be plenty to amortize call overhead.</span></span><br><span class="line">  <span class="keyword">int</span> budget_ms = <span class="number">500</span>;</span><br><span class="line">  MonoTime deadline = MonoTime::Now() + MonoDelta::FromMilliseconds(budget_ms);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int64_t</span> rows_scanned = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (iter-&gt;HasNext() &amp;&amp; !scanner-&gt;has_fulfilled_limit()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (PREDICT_FALSE(FLAGS_scanner_inject_latency_on_each_batch_ms &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">      SleepFor(MonoDelta::FromMilliseconds(FLAGS_scanner_inject_latency_on_each_batch_ms));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照block块读取</span></span><br><span class="line">    Status s = iter-&gt;NextBlock(&amp;block);</span><br><span class="line">    <span class="keyword">if</span> (PREDICT_FALSE(!s.ok())) &#123;</span><br><span class="line">      LOG(WARNING) &lt;&lt; <span class="string">"Copying rows from internal iterator for request "</span></span><br><span class="line">                   &lt;&lt; SecureShortDebugString(*req);</span><br><span class="line">      *error_code = TabletServerErrorPB::UNKNOWN_ERROR;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PREDICT_TRUE(block.nrows() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">// Count the number of rows scanned, regardless of predicates or deletions.</span></span><br><span class="line">      <span class="comment">// The collector will separately count the number of rows actually returned to</span></span><br><span class="line">      <span class="comment">// the client.</span></span><br><span class="line">      rows_scanned += block.nrows();</span><br><span class="line">      <span class="keyword">if</span> (scanner-&gt;spec().has_limit()) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> rows_left = scanner-&gt;spec().limit() - scanner-&gt;num_rows_returned();</span><br><span class="line">        DCHECK_GT(rows_left, <span class="number">0</span>);  <span class="comment">// Guaranteed by has_fulfilled_limit()</span></span><br><span class="line">        block.selection_vector()-&gt;ClearToSelectAtMost(<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(rows_left));</span><br><span class="line">      &#125;</span><br><span class="line">      result_collector-&gt;HandleRowBlock(scanner.<span class="built_in">get</span>(), block);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response_size &gt;= batch_size_bytes) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//省略返回数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过Scan的读取（第一次和第二次），开始初始化RowIterator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Status Tablet::NewRowIterator(const Schema&amp; projection,</span><br><span class="line">                              unique_ptr&lt;RowwiseIterator&gt;* iter) const &#123;</span><br><span class="line">  RowIteratorOptions opts;</span><br><span class="line">  &#x2F;&#x2F; Yield current rows.</span><br><span class="line">  opts.snap_to_include &#x3D; MvccSnapshot(mvcc_);</span><br><span class="line">  opts.projection &#x3D; &amp;projection;</span><br><span class="line">  return NewRowIterator(std::move(opts), iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status Tablet::NewRowIterator(RowIteratorOptions opts,</span><br><span class="line">                              unique_ptr&lt;RowwiseIterator&gt;* iter) const &#123;</span><br><span class="line">  RETURN_IF_STOPPED_OR_CHECK_STATE(kOpen);</span><br><span class="line">  if (metrics_) &#123;</span><br><span class="line">    metrics_-&gt;scans_started-&gt;Increment();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  VLOG_WITH_PREFIX(2) &lt;&lt; &quot;Created new Iterator for snapshot range: (&quot;</span><br><span class="line">                      &lt;&lt; (opts.snap_to_exclude ? opts.snap_to_exclude-&gt;ToString() : &quot;-Inf&quot;)</span><br><span class="line">                      &lt;&lt; &quot;, &quot; &lt;&lt; opts.snap_to_include.ToString() &lt;&lt; &quot;)&quot;;</span><br><span class="line">	&#x2F;&#x2F;开始初始化迭代器</span><br><span class="line">  iter-&gt;reset(new Iterator(this, std::move(opts)));</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>

<p>迭代器主要包括，继承自RowwiseIterator的有MergeIterator，UnionIterator，MaterializingIterator，PredicateEvaluatingIterator，集成自ColumnwiseIterator的有DeltaApplier，CFileSet负责读取</p>
<p>这里初始化第一部分：核心Iterator来自NewRowIteratorWithBounds或NewRowIterator方法，Iterator的初始化函数如下，初始化了MergeIterator或UnionIterator。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Status Tablet::Iterator::Init(ScanSpec *spec) &#123;</span><br><span class="line">  RETURN_NOT_OK(tablet_-&gt;CheckHasNotBeenStopped());</span><br><span class="line">  DCHECK(iter_.<span class="built_in">get</span>() == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  RETURN_NOT_OK(tablet_-&gt;GetMappedReadProjection(projection_, &amp;projection_));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;IterWithBounds&gt; iters;</span><br><span class="line">  <span class="comment">//第一步初始化，memRowSet和diskRowSet的Iterator</span></span><br><span class="line">  RETURN_NOT_OK(tablet_-&gt;CaptureConsistentIterators(opts_, spec, &amp;iters));</span><br><span class="line">  TRACE_COUNTER_INCREMENT(<span class="string">"rowset_iterators"</span>, iters.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第二步初始化</span></span><br><span class="line">  <span class="keyword">switch</span> (opts_.order) &#123;</span><br><span class="line">    <span class="keyword">case</span> ORDERED:</span><br><span class="line">      iter_ = NewMergeIterator(MergeIteratorOptions(opts_.include_deleted_rows), <span class="built_in">std</span>::<span class="built_in">move</span>(iters));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> UNORDERED:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      iter_ = NewUnionIterator(<span class="built_in">std</span>::<span class="built_in">move</span>(iters));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据规格进行初始化</span></span><br><span class="line">  RETURN_NOT_OK(iter_-&gt;Init(spec));</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在MergeIterator和UnionIterator的InitSubIterators方法中，都会调用nitAndMaybeWrap初始化内部迭代器。其中初始化的是PredicateEvaluatingIterator，多个迭代器都只是RowwiseIterator的封装，执行了谓词下推，合并等逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">MergeIterator::InitSubIterators</span><span class="params">(ScanSpec *spec)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize all the sub iterators.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : orig_iters_) &#123;</span><br><span class="line">    ScanSpec *spec_copy = spec != <span class="literal">nullptr</span> ? scan_spec_copies_.Construct(*spec) : <span class="literal">nullptr</span>;</span><br><span class="line">    RETURN_NOT_OK(InitAndMaybeWrap(&amp;i.iter, spec_copy));</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;MergeIterState&gt; <span class="title">state</span><span class="params">(<span class="keyword">new</span> MergeIterState(<span class="built_in">std</span>::<span class="built_in">move</span>(i)))</span></span>;</span><br><span class="line">    RETURN_NOT_OK(state-&gt;Init(&amp;decoded_bounds_memory_));</span><br><span class="line">    states_.push_back(*state.<span class="built_in">release</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  orig_iters_.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Since we handle predicates in all the wrapped iterators, we can clear</span></span><br><span class="line">  <span class="comment">// them here.</span></span><br><span class="line">  <span class="keyword">if</span> (spec != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    spec-&gt;RemovePredicates();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PredicateEvaluatingIterator内部包含底层的Iterator，只是一个包装，有自己的谓词下推逻辑，数据读取还是靠底层Iterator</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">UnionIterator::InitSubIterators</span><span class="params">(ScanSpec *spec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : iters_) &#123;</span><br><span class="line">    ScanSpec *spec_copy = spec != <span class="literal">nullptr</span> ? scan_spec_copies_.Construct(*spec) : <span class="literal">nullptr</span>;</span><br><span class="line">    RETURN_NOT_OK(InitAndMaybeWrap(&amp;i.iter, spec_copy));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The union iterator doesn't care about these, so let's drop them now to</span></span><br><span class="line">    <span class="comment">// free some memory.</span></span><br><span class="line">    i.encoded_bounds.reset();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Since we handle predicates in all the wrapped iterators, we can clear</span></span><br><span class="line">  <span class="comment">// them here.</span></span><br><span class="line">  <span class="keyword">if</span> (spec != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    spec-&gt;RemovePredicates();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitAndMaybeWrap</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;RowwiseIterator&gt;* base_iter,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ScanSpec *spec)</span> </span>&#123;</span><br><span class="line">  RETURN_NOT_OK((*base_iter)-&gt;Init(spec));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (spec != <span class="literal">nullptr</span> &amp;&amp; !spec-&gt;predicates().empty()) &#123;</span><br><span class="line">    <span class="comment">// Underlying iterator did not accept all predicates. Wrap it.</span></span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;RowwiseIterator&gt; <span class="title">wrapper</span><span class="params">(<span class="keyword">new</span> PredicateEvaluatingIterator(<span class="built_in">std</span>::<span class="built_in">move</span>(*base_iter)))</span></span>;</span><br><span class="line">    RETURN_NOT_OK(wrapper-&gt;Init(spec));</span><br><span class="line">    *base_iter = <span class="built_in">std</span>::<span class="built_in">move</span>(wrapper);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CaptureConsistentIterators会尝试读取memRowSet和diskRowSet的iterator</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Tablet::CaptureConsistentIterators</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> RowIteratorOptions&amp; opts,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> ScanSpec* spec,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">vector</span>&lt;IterWithBounds&gt;* iters)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">shared_lock&lt;rw_spinlock&gt; <span class="title">l</span><span class="params">(component_lock_)</span></span>;</span><br><span class="line">  RETURN_IF_STOPPED_OR_CHECK_STATE(kOpen);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Construct all the iterators locally first, so that if we fail</span></span><br><span class="line">  <span class="comment">// in the middle, we don't modify the output arguments.</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;IterWithBounds&gt; ret;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取MemRowSet</span></span><br><span class="line">  <span class="comment">// Grab the memrowset iterator.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;RowwiseIterator&gt; ms_iter;</span><br><span class="line">    RETURN_NOT_OK(components_-&gt;memrowset-&gt;NewRowIterator(opts, &amp;ms_iter));</span><br><span class="line">    IterWithBounds mrs_iwb;</span><br><span class="line">    mrs_iwb.iter = <span class="built_in">std</span>::<span class="built_in">move</span>(ms_iter);</span><br><span class="line">    ret.emplace_back(<span class="built_in">std</span>::<span class="built_in">move</span>(mrs_iwb));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取在已提交事务中的MemRowSet</span></span><br><span class="line">  <span class="comment">// Capture any iterators for memrowsets whose inserts were added as a part of</span></span><br><span class="line">  <span class="comment">// committed transactions.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; txn_mrs : components_-&gt;txn_memrowsets) &#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;RowwiseIterator&gt; txn_ms_iter;</span><br><span class="line">    RETURN_NOT_OK(txn_mrs-&gt;NewRowIterator(opts, &amp;txn_ms_iter));</span><br><span class="line">    IterWithBounds txn_mrs_iwb;</span><br><span class="line">    txn_mrs_iwb.iter = <span class="built_in">std</span>::<span class="built_in">move</span>(txn_ms_iter);</span><br><span class="line">    ret.emplace_back(<span class="built_in">std</span>::<span class="built_in">move</span>(txn_mrs_iwb));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据Key范围找到RowSet</span></span><br><span class="line">  <span class="comment">// Cull row-sets in the case of key-range queries.</span></span><br><span class="line">  <span class="keyword">if</span> (spec != <span class="literal">nullptr</span> &amp;&amp; (spec-&gt;lower_bound_key() || spec-&gt;exclusive_upper_bound_key())) &#123;</span><br><span class="line">    optional&lt;Slice&gt; lower_bound = spec-&gt;lower_bound_key() ?</span><br><span class="line">        optional&lt;Slice&gt;(spec-&gt;lower_bound_key()-&gt;encoded_key()) : nullopt;</span><br><span class="line">    optional&lt;Slice&gt; upper_bound = spec-&gt;exclusive_upper_bound_key() ?</span><br><span class="line">        optional&lt;Slice&gt;(spec-&gt;exclusive_upper_bound_key()-&gt;encoded_key()) : nullopt;</span><br><span class="line">    <span class="built_in">vector</span>&lt;RowSet*&gt; interval_sets;</span><br><span class="line">    components_-&gt;rowsets-&gt;FindRowSetsIntersectingInterval(lower_bound, upper_bound, &amp;interval_sets);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* rs : interval_sets) &#123;</span><br><span class="line">      IterWithBounds iwb;</span><br><span class="line">      RETURN_NOT_OK_PREPEND(rs-&gt;NewRowIteratorWithBounds(opts, &amp;iwb),</span><br><span class="line">                            Substitute(<span class="string">"Could not create iterator for rowset $0"</span>,</span><br><span class="line">                                       rs-&gt;ToString()));</span><br><span class="line">      ret.emplace_back(<span class="built_in">std</span>::<span class="built_in">move</span>(iwb));</span><br><span class="line">    &#125;</span><br><span class="line">    *iters = <span class="built_in">std</span>::<span class="built_in">move</span>(ret);</span><br><span class="line">    <span class="keyword">return</span> Status::OK();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果没有Key范围，那就查询所有RowSet</span></span><br><span class="line">  <span class="comment">// If there are no encoded predicates of the primary keys, then</span></span><br><span class="line">  <span class="comment">// fall back to grabbing all rowset iterators.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;RowSet&gt;&amp; rs : components_-&gt;rowsets-&gt;all_rowsets()) &#123;</span><br><span class="line">    IterWithBounds iwb;</span><br><span class="line">    RETURN_NOT_OK_PREPEND(rs-&gt;NewRowIteratorWithBounds(opts, &amp;iwb),</span><br><span class="line">                          Substitute(<span class="string">"Could not create iterator for rowset $0"</span>,</span><br><span class="line">                                     rs-&gt;ToString()));</span><br><span class="line">    ret.emplace_back(<span class="built_in">std</span>::<span class="built_in">move</span>(iwb));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Swap results into the parameters.</span></span><br><span class="line">  *iters = <span class="built_in">std</span>::<span class="built_in">move</span>(ret);</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当MemRowSet初始化Iterator时，会直接通过SeekToStart完成数据检索</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MemRowSet::Iterator* <span class="title">MemRowSet::NewIterator</span><span class="params">(<span class="keyword">const</span> RowIteratorOptions&amp; opts)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MemRowSet::Iterator(shared_from_this(), tree_.NewIterator(), opts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MemRowSet::Iterator* <span class="title">MemRowSet::NewIterator</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO(todd): can we kill this function? should be only used by tests?</span></span><br><span class="line">  RowIteratorOptions opts;</span><br><span class="line">  opts.projection = &amp;schema();</span><br><span class="line">  <span class="keyword">return</span> NewIterator(opts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">MemRowSet::NewRowIterator</span><span class="params">(<span class="keyword">const</span> RowIteratorOptions&amp; opts,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="built_in">unique_ptr</span>&lt;RowwiseIterator&gt;* out)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  out-&gt;reset(NewIterator(opts));</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br><span class="line">MemRowSet::Iterator::Iterator(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">const</span> MemRowSet&gt;&amp; mrs,</span><br><span class="line">                              MemRowSet::MSBTIter* iter,</span><br><span class="line">                              RowIteratorOptions opts)</span><br><span class="line">    : memrowset_(mrs),</span><br><span class="line">      iter_(iter),</span><br><span class="line">      opts_(<span class="built_in">std</span>::<span class="built_in">move</span>(opts)),</span><br><span class="line">      projector_(</span><br><span class="line">          GenerateAppropriateProjector(&amp;mrs-&gt;schema_nonvirtual(), opts_.projection)),</span><br><span class="line">      delta_projector_(&amp;mrs-&gt;schema_nonvirtual(), opts_.projection),</span><br><span class="line">      projection_vc_is_deleted_idx_(opts_.projection-&gt;first_is_deleted_virtual_column_idx()),</span><br><span class="line">      state_(kUninitialized) &#123;</span><br><span class="line">  <span class="comment">// TODO(todd): various code assumes that a newly constructed iterator</span></span><br><span class="line">  <span class="comment">// is pointed at the beginning of the dataset. This causes a redundant</span></span><br><span class="line">  <span class="comment">// seek. Could make this lazy instead, or change the semantics so that</span></span><br><span class="line">  <span class="comment">// a seek is required (probably the latter)</span></span><br><span class="line">  iter_-&gt;SeekToStart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当diskRowSet初始化Iterator时，会初始化MaterializingIterator，而MaterializingIterator包含ColumnwiseIterator</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DiskRowSet::NewRowIterator</span><span class="params">(<span class="keyword">const</span> RowIteratorOptions&amp; opts,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="built_in">unique_ptr</span>&lt;RowwiseIterator&gt;* out)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  DCHECK(open_);</span><br><span class="line">  <span class="function">shared_lock&lt;rw_spinlock&gt; <span class="title">l</span><span class="params">(component_lock_)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//可以看出base Iter是通过CFileSet::Iterator检索</span></span><br><span class="line">  <span class="function"><span class="built_in">shared_ptr</span>&lt;CFileSet::Iterator&gt; <span class="title">base_iter</span><span class="params">(base_data_-&gt;NewIterator(opts.projection,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                   opts.io_context))</span></span>;</span><br><span class="line">                                                                   </span><br><span class="line">  <span class="comment">//delta是由ColumnwiseIterator包裹的DeltaIterator检索</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;ColumnwiseIterator&gt; col_iter;</span><br><span class="line">  RETURN_NOT_OK(delta_tracker_-&gt;WrapIterator(base_iter, opts, &amp;col_iter));</span><br><span class="line"></span><br><span class="line">  *out = NewMaterializingIterator(<span class="built_in">std</span>::<span class="built_in">move</span>(col_iter));</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>delta data由DeltaTracker检索，合并undo，redo和delta memberstore</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeltaTracker::WrapIterator</span><span class="params">(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;CFileSet::Iterator&gt; &amp;base,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> RowIteratorOptions&amp; opts,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="built_in">unique_ptr</span>&lt;ColumnwiseIterator&gt;* out)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;DeltaIterator&gt; iter;</span><br><span class="line">  RETURN_NOT_OK(NewDeltaIterator(opts, &amp;iter));</span><br><span class="line"></span><br><span class="line">  out-&gt;reset(<span class="keyword">new</span> DeltaApplier(opts, base, <span class="built_in">std</span>::<span class="built_in">move</span>(iter)));</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeltaTracker::NewDeltaIterator</span><span class="params">(<span class="keyword">const</span> RowIteratorOptions&amp; opts,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      WhichStores which,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="built_in">unique_ptr</span>&lt;DeltaIterator&gt;* out)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;DeltaStore&gt;&gt; stores;</span><br><span class="line">  <span class="comment">//收集数据undo redo deltastore的数据</span></span><br><span class="line">  CollectStores(&amp;stores, which);</span><br><span class="line">  <span class="comment">//调用DeltaIteratorMerger初始化</span></span><br><span class="line">  <span class="keyword">return</span> DeltaIteratorMerger::Create(stores, opts, out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeltaTracker::CollectStores</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;DeltaStore&gt;&gt;* deltas,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 WhichStores which)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;rw_spinlock&gt; <span class="title">lock</span><span class="params">(component_lock_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (which != REDOS_ONLY) &#123;</span><br><span class="line">    <span class="comment">//合并undo</span></span><br><span class="line">    deltas-&gt;assign(undo_delta_stores_.<span class="built_in">begin</span>(), undo_delta_stores_.<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (which != UNDOS_ONLY) &#123;</span><br><span class="line">  	<span class="comment">//合并redo和delta</span></span><br><span class="line">    deltas-&gt;insert(deltas-&gt;<span class="built_in">end</span>(), redo_delta_stores_.<span class="built_in">begin</span>(), redo_delta_stores_.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (dms_exists_ &amp;&amp; !dms_-&gt;Empty()) &#123;</span><br><span class="line">      deltas-&gt;push_back(dms_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>base data由CFileSet检索，是ColumnwiseIterator的实现类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CFileSet</span>:</span>:Iterator : <span class="keyword">public</span> ColumnwiseIterator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">Init</span><span class="params">(ScanSpec *spec)</span> OVERRIDE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">PrepareBatch</span><span class="params">(<span class="keyword">size_t</span> *nrows)</span> OVERRIDE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">InitializeSelectionVector</span><span class="params">(SelectionVector *sel_vec)</span> OVERRIDE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">MaterializeColumn</span><span class="params">(ColumnMaterializationContext *ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取完base data和delta data后，由DeltaApplier合并并返回结果，DeltaApplier是ColumnwiseIterator的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A DeltaApplier takes in a base ColumnwiseIterator along with a</span></span><br><span class="line"><span class="comment">// DeltaIterator. It is responsible for applying the updates coming</span></span><br><span class="line"><span class="comment">// from the delta iterator to the results of the base iterator.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeltaApplier</span> <span class="title">final</span> :</span> <span class="keyword">public</span> ColumnwiseIterator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Status <span class="title">Init</span><span class="params">(ScanSpec* spec)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">Status <span class="title">PrepareBatch</span><span class="params">(<span class="keyword">size_t</span>* nrows)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="comment">//省略其他</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">DeltaApplier::Init</span><span class="params">(ScanSpec* spec)</span> </span>&#123;</span><br><span class="line">  RETURN_NOT_OK(base_iter_-&gt;Init(spec));</span><br><span class="line">  RETURN_NOT_OK(delta_iter_-&gt;Init(spec));</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeltaApplier::MaterializeColumn</span><span class="params">(ColumnMaterializationContext* ctx)</span> </span>&#123;</span><br><span class="line">  DCHECK(!first_prepare_) &lt;&lt; <span class="string">"PrepareBatch() must be called at least once"</span>;</span><br><span class="line">  <span class="comment">// Data with updates cannot be evaluated at the decoder-level.</span></span><br><span class="line">  <span class="keyword">if</span> (delta_iter_-&gt;MayHaveDeltas()) &#123;</span><br><span class="line">    ctx-&gt;SetDecoderEvalNotSupported();</span><br><span class="line">    RETURN_NOT_OK(base_iter_-&gt;MaterializeColumn(ctx));</span><br><span class="line">    <span class="comment">//应用delta的数据更新</span></span><br><span class="line">    RETURN_NOT_OK(delta_iter_-&gt;ApplyUpdates(ctx-&gt;col_idx(), ctx-&gt;block(), *ctx-&gt;sel()));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    RETURN_NOT_OK(base_iter_-&gt;MaterializeColumn(ctx));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>














                    
                </div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                    </div>
                    <div>
                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/2024/02/26/2_%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E5%9D%91/"
                                   title="工作中的坑"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">工作中的坑</span>
                                        <span class="post-nav-item">上一篇</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/2023/12/31/%E5%AD%98%E5%82%A8%E9%80%89%E5%9E%8B%E6%B5%8B%E8%AF%95/"
                                   title="存储选型测试"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">存储选型测试</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    






                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="copyright-info info-item">
        &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2024
        
            &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">EmiyaQ</a>
        
    </div>

    <div class="theme-info info-item">
        由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
    </div>

    

    

    
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="post-tools-list border-box">
        <!-- PC encrypt again -->
        

        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <!-- toggle mode -->
        
            <li class="tools-item tool-toggle-theme-mode flex-center">
                <i class="fas fa-moon"></i>
            </li>
        

        <!-- rss -->
        

        <!-- to bottom -->
        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        
    </div>
</div>

            </div>
        </div>
    
</main>





<!-- common js -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local search -->

    
<script src="/js/local-search.js"></script>



<!-- lazyload -->

    
<script src="/js/lazyload.js"></script>



<div class="pjax">
    <!-- home page -->
    

    <!-- post page -->
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        
            
<script src="/js/post/toc.js"></script>

        

        <!-- copyright-info -->
        

        <!-- share -->
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->

    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart()
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd()
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'))
            KEEP.initExecute()
        });
    });
</script>




</body>
</html>
