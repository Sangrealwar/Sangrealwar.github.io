<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="人生，总有些黑暗的隧道需要自己穿越">
    <meta name="author" content="Keep Team">
    
    <title>
        
            Presto |
        
        Keep Theme
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.svg">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"Keep Theme","author":"Keep Team","avatar":"/images/avatar.svg","logo":"/images/logo.svg","favicon":"/images/logo.svg"},"menu":{"home":"/","archives":"/archives"},"first_screen":{"enable":false,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"Keep writing and Keep loving.","hitokoto":false},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":false,"hide_header":true},"home":{"announcement":null,"category":false,"tag":false,"post_datetime":"updated"},"post":{"author_badge":{"enable":true,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":false,"min2read":false},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":false,"share":false,"reward":{"enable":false,"img_link":null,"text":null,"icon":null}},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"toc":{"enable":false,"number":false,"expand_all":false,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":false,"site_uv":false,"site_pv":false,"page_pv":false}},"local_search":{"enable":false,"preload":false},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.36"},"waline":{"server_url":null,"reaction":false,"version":"3.2.1"},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":false},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":false},"footer":{"since":2020,"word_count":false,"site_deploy":{"enable":false,"provider":"github","url":null},"record":{"enable":false,"list":[{"code":null,"link":null}]}},"inject":{"enable":false,"css":[null],"js":[null]},"root":"","source_data":{},"version":"4.2.3"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left flex-start border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               Keep Theme
            </a>
        </div>

        <div class="right border-box">
            <div class="pc border-box">
                <ul class="menu-list border-box">
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/">
                                
                                首页
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/archives">
                                
                                归档
                                
                            </a>
                            
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile border-box flex-start">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list border-box">
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/">
                            
                            首页
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/archives">
                            
                            归档
                        </a>
                        
                    </label>
                    
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        Presto
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/avatar.svg">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">Keep Team</span>
                                
                                    <span class="author-badge">Lv4</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2023-05-11 23:28:27</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Thu Oct 10 2024 22:00:44 GMT+0800">2024-10-10 22:00:44</span>
            </span>
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/">分布式组件</a></li>
                        
                    
                </ul>
            </span>
        

        

        
        
        
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body ">
                    

                    
                         <blockquote>
<p>Presto是一款开源的高效的查询引擎。目前市面上有两款Presto，一个是Prestodb，由Facebook开源维护。一个是Trino（又名Prestosql），由Starburst公司开源维护。其中Presto的核心创始人之前在Facebook研发，19年后离开Facebook，重新fork分支后开发了trino，所以两款Presto的基础思想都类似，为避免歧义，本文分析的是trino，以下Presto均代表Trino，源码版本为412</p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Presto是一个大规模并行处理MPP（Massively parallel processing）的分布式SQL查询引擎。主要使用场景有：联邦查询，即席查询，通过分配处理任务来实现横向扩展提高强大的处理能力，同时也能适应较大数据量的ETL查询。</p>
<p>在BI业务中，如果业务方想要在PB级别数据库中快速提取数据，形成报表，往往有以下几种方式。1. 通过Hive实现数据提取，2. 开发对应的取数程序，按照固定报表格式，形成BI报表，供业务方查询。3. 依赖关系型数据库（如Oracle，PostgreSQL）连表查询。但上述方式，hive取数耗时较久，取数程序报表格式固定不灵活，连表查询分库分表无法实现。这种场景业界也有许多组件选型，例如Impala，kylin，druid，starRocks等。相比之下，我们选择了Presto，能够低延时的满足灵活分析的场景，而且存算分离后，也可以通过横向扩展来应对峰值查询。</p>
<p>本文以查询计划生成为切入点，分享实践中对慢Sql的定位与优化，以此加深对Presto的了解。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>Presto架构图如下：</p>
<p><img src="/2023/05/11/3_Presto/image2.png" alt="image-202206251715403"></p>
<h2 id="查询计划是什么"><a href="#查询计划是什么" class="headerlink" title="查询计划是什么"></a>查询计划是什么</h2><p>查询计划是一个过程，是由 LogicalPlanner根据Sql语句分析后的结果，生成逻辑执行计划，逻辑执行计划经过各种优化器处理后，最终输出的查询执行计划分段，并交由调度执行器分配到不同的worker执行。</p>
<p>查询计划的直观体现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Fragment 1 [HASH]</span><br><span class="line">    CPU: 2.65ms, Scheduled: 2.81ms, Input: 0 rows (0B); per task: avg.: 0.00 std.dev.: 0.00, Output: 0 rows (0B)</span><br><span class="line">    Output layout: [u_key]</span><br><span class="line">    Output partitioning: SINGLE []</span><br><span class="line">    Stage Execution Strategy: UNGROUPED_EXECUTION</span><br><span class="line">    Project[]</span><br><span class="line">    │   Layout: [u_key:varchar]</span><br><span class="line">    │   Estimates: &#123;rows: ? (?), cpu: ?, memory: ?, network: ?&#125;</span><br><span class="line">    │   CPU: 0.00ns (?%), Scheduled: 0.00ns (0.00%), Output: 0 rows (0B)</span><br><span class="line">    │   Input avg.: 0.00 rows, Input std.dev.: ?%</span><br><span class="line">    └─ Aggregate(FINAL)[u_key][$hashvalue]</span><br><span class="line">       │   Layout: [u_key:varchar, $hashvalue:bigint]</span><br><span class="line">       │   Estimates: &#123;rows: ? (?), cpu: ?, memory: ?, network: ?&#125;</span><br><span class="line">       │   CPU: 0.00ns (?%), Scheduled: 0.00ns (0.00%), Output: 0 rows (0B)</span><br><span class="line">       │   Input avg.: 0.00 rows, Input std.dev.: ?%</span><br><span class="line">       │   Collisions avg.: ? (?% est.), Collisions std.dev.: ?%</span><br><span class="line">       └─ LocalExchange[HASH][$hashvalue] (&quot;u_key&quot;)</span><br><span class="line">          │   Layout: [u_key:varchar, $hashvalue:bigint]</span><br><span class="line">          │   Estimates: &#123;rows: ? (?), cpu: ?, memory: ?, network: ?&#125;</span><br><span class="line">          │   CPU: 0.00ns (?%), Scheduled: 0.00ns (0.00%), Output: 0 rows (0B)</span><br><span class="line">          │   Input avg.: 0.00 rows, Input std.dev.: ?%</span><br><span class="line">          └─ RemoteSource[2]</span><br><span class="line">                 Layout: [u_key:varchar, $hashvalue_4:bigint]</span><br><span class="line">                 CPU: 0.00ns (?%), Scheduled: 0.00ns (0.00%), Output: 0 rows (0B)</span><br><span class="line">                 Input avg.: 0.00 rows, Input std.dev.: ?%</span><br></pre></td></tr></table></figure>



<h2 id="查询计划的生成过程"><a href="#查询计划的生成过程" class="headerlink" title="查询计划的生成过程"></a>查询计划的生成过程</h2><p>查询过程中的核心类图交互关系如下，其中，查询计划生成后，会由SqlQueryExecution进行调度执行</p>
<p><img src="/2023/05/11/3_Presto/image4.png" alt="image-2022062517"></p>
<h3 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h3><p>jdbc驱动首先通过TrinoDriver初始化一个TrinoConnection连接，该连接通过注册TrinoStatement来实现具体的sql执行，这个操作和常见的数据库连接类似，在TrinoStatemen最终会将查询委托给internalExecute方法。</p>
<p>该方法通过TrinoConnection的startQuery方法（io.trino.jdbc.TrinoConnection#startQuery）创建StatementClientV1对象，这里设置好角色权限，请求uri，超时时间等。同时通过静态方法TrinoResultSet.create，获取返回结果（currentResult字段）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">io.trino.jdbc.TrinoStatement#internalExecute</span><br><span class="line">final boolean internalExecute(String sql)</span><br><span class="line">            throws SQLException</span><br><span class="line">    &#123;</span><br><span class="line">        ...前置检查...</span><br><span class="line">        </span><br><span class="line">        StatementClient client &#x3D; null;</span><br><span class="line">        TrinoResultSet resultSet &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">        		&#x2F;&#x2F;执行查询请求</span><br><span class="line">            client &#x3D; connection().startQuery(sql, getStatementSessionProperties());</span><br><span class="line">            if (client.isFinished()) &#123;</span><br><span class="line">                QueryStatusInfo finalStatusInfo &#x3D; client.finalStatusInfo();</span><br><span class="line">                if (finalStatusInfo.getError() !&#x3D; null) &#123;</span><br><span class="line">                    throw resultsException(finalStatusInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            executingClient.set(client);</span><br><span class="line">            WarningsManager warningsManager &#x3D; new WarningsManager();</span><br><span class="line">            currentWarningsManager.set(Optional.of(warningsManager));</span><br><span class="line">            &#x2F;&#x2F;获取查询结果</span><br><span class="line">            resultSet &#x3D; TrinoResultSet.create(this, client, maxRows.get(), progressConsumer, warningsManager);</span><br><span class="line"></span><br><span class="line">						...拿到返回的数据，如果是更新，则需处理事务相关变量</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        ...各种catch，清理变量，关闭连接</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>StatementClientV1是一个线程安全的对象，维护着本次查询的任务状态，以及后续查询的交互，当StatementClientV1初始化时方法中执行http请求（/v1/statement），同时维护了当前查询结果（currentResults），当前查询状态（state）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">io.trino.client.StatementClientV1#StatementClientV1</span><br><span class="line">public StatementClientV1(OkHttpClient httpClient, ClientSession session, String query, Optional&lt;Set&lt;String&gt;&gt; clientCapabilities)</span><br><span class="line">    &#123;</span><br><span class="line">        ... 前置check，字段赋值</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F;生成请求对象</span><br><span class="line">        Request request &#x3D; buildQueryRequest(session, query);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;执行请求</span><br><span class="line">        JsonResponse&lt;QueryResults&gt; response &#x3D; JsonResponse.execute(QUERY_RESULTS_CODEC, httpClient, request, OptionalLong.empty());</span><br><span class="line">        if ((response.getStatusCode() !&#x3D; HTTP_OK) || !response.hasValue()) &#123;</span><br><span class="line">            state.compareAndSet(State.RUNNING, State.CLIENT_ERROR);</span><br><span class="line">            throw requestFailedException(&quot;starting query&quot;, request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;返回结果</span><br><span class="line">        processResponse(response.getHeaders(), response.getValue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>由StatementClientV1发起第一次请求后，会返回TrinoResultSet，这是ResultSet的子类，内部包含了ResultsPageIterator迭代器（继承自Iterator，迭代器重写了computeNext方法，而该方法会被迭代器（Iterator）的next触发，当从ResultSet获取下一行数据时，会触发该方法获取下一条数据（注意这里为了提高传输效率，并不是一条一条数据返回，而是每一批数据返回，每一批数据大小默认1M），获取数据代码如下如所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prestoTemplate.query(query, new ResultSetExtractor&lt;Object&gt;() &#123;</span><br><span class="line"> @Override</span><br><span class="line"> public Object extractData(ResultSet resultSet) throws SQLException, DataAccessException &#123;</span><br><span class="line"> 	&#x2F;&#x2F; 发起远程请求</span><br><span class="line">   while (resultSet.next()) &#123;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当resultSet.next调用时，最终会执行到advance方法，该方法使用类似游标的做法，会不断获取下一个游标，如果有，则继续查询（url：/v1/statement/executing），如果没有nextUri，则说明查询结束。这里有一个重试机制，当远程查询失败时，会尝试重试，每次重试会休眠100ms，当超过请求时间时会报错退出重试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">io.trino.client.StatementClientV1#advance</span><br><span class="line">public boolean advance()</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isRunning()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F;获取下一个游标</span><br><span class="line">        URI nextUri &#x3D; currentStatusInfo().getNextUri();</span><br><span class="line">        if (nextUri &#x3D;&#x3D; null) &#123;</span><br><span class="line">        		&#x2F;&#x2F;查询结束的标识：没有数据了</span><br><span class="line">            state.compareAndSet(State.RUNNING, State.FINISHED);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Request request &#x3D; prepareRequest(HttpUrl.get(nextUri)).build();</span><br><span class="line">				..参数初始化</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (isClientAborted()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (attempts &gt; 0) &#123;</span><br><span class="line">                ..尝试获取</span><br><span class="line">            &#125;</span><br><span class="line">            attempts++;</span><br><span class="line"></span><br><span class="line">            JsonResponse&lt;QueryResults&gt; response;</span><br><span class="line">            try &#123;</span><br><span class="line">            		&#x2F;&#x2F;执行下一个游标的查询</span><br><span class="line">                response &#x3D; JsonResponse.execute(QUERY_RESULTS_CODEC, httpClient, request, OptionalLong.of(MAX_MATERIALIZED_JSON_RESPONSE_SIZE));</span><br><span class="line">            &#125;</span><br><span class="line">            catch (RuntimeException e) &#123;</span><br><span class="line">                cause &#x3D; e;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ((response.getStatusCode() &#x3D;&#x3D; HTTP_OK) &amp;&amp; response.hasValue()) &#123;</span><br><span class="line">             		&#x2F;&#x2F;查询结束的标识：查到数据了</span><br><span class="line">                processResponse(response.getHeaders(), response.getValue());</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!shouldRetry(response.getStatusCode())) &#123;</span><br><span class="line">                state.compareAndSet(State.RUNNING, State.CLIENT_ERROR);</span><br><span class="line">                throw requestFailedException(&quot;fetching next&quot;, request, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h3><h4 id="与客户端数据交互"><a href="#与客户端数据交互" class="headerlink" title="与客户端数据交互"></a>与客户端数据交互</h4><p><img src="/2023/05/11/3_Presto/image10.png" alt="image-2022062517"></p>
<ul>
<li>主要逻辑</li>
</ul>
<ol>
<li>通过/v1/statement接口，注册查询请求。由io.trino.dispatcher.QueuedStatementResource#postStatement具体实现。主要生成queryId。</li>
<li>通过/v1/statement/queued/{queryId}/{slug}/{token}。发起查询请求，由io.trino.dispatcher.DispatchManager具体实现。主要调用createQuery，生成查询执行计划，并执行。</li>
<li>通过/v1/statement/executing/{queryId}/{slug}/{token}。获取查询结果，由io.trino.server.protocol.Query具体实现。主要从ExchangeDataSource获取结果，ExchangeDataSource内部会由QueryStateMachine将执行结果通过钩子方法addInput写入缓冲区，多次循环获取到所需结果。</li>
</ol>
<ul>
<li>主要类</li>
</ul>
<p>QueuedStatementResource</p>
<p>Web接口的控制类，负责接收jdbc客户端发起查询请求，并触发DispatchManager创建查询。</p>
<p>ExecutingStatementResource</p>
<p>Web接口的控制类，负责接收jdbc客户端获取查询结果，接收QueryStateMachine填充的查询结果，返回客户端。</p>
<h4 id="语法解析及发起查询"><a href="#语法解析及发起查询" class="headerlink" title="语法解析及发起查询"></a>语法解析及发起查询</h4><p><img src="/2023/05/11/3_Presto/image11.png" alt="image-2022062517"></p>
<ul>
<li>主要逻辑</li>
</ul>
<ol>
<li>核心方法是DispatchManager的createQueryInternal</li>
</ol>
<p>堆栈路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io.trino.dispatcher.QueuedStatementResource#getStatus(io.trino.dispatcher.QueuedStatementResource.Query, long, io.airlift.units.Duration, javax.ws.rs.core.UriInfo)</span><br><span class="line">io.trino.dispatcher.QueuedStatementResource.Query#waitForDispatched</span><br><span class="line">io.trino.dispatcher.QueuedStatementResource.Query#submitIfNeeded</span><br><span class="line">io.trino.dispatcher.DispatchManager#createQuery</span><br><span class="line">io.trino.dispatcher.DispatchManager#createQueryInternal</span><br></pre></td></tr></table></figure>

<p>核心方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">io.trino.dispatcher.DispatchManager#createQueryInternal</span><br><span class="line">private &lt;C&gt; void createQueryInternal(QueryId queryId, Slug slug, SessionContext sessionContext, String query, ResourceGroupManager&lt;C&gt; resourceGroupManager)</span><br><span class="line">    &#123;</span><br><span class="line">        Session session &#x3D; null;</span><br><span class="line">        PreparedQuery preparedQuery &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (query.length() &gt; maxQueryLength) &#123;</span><br><span class="line">                int queryLength &#x3D; query.length();</span><br><span class="line">                query &#x3D; query.substring(0, maxQueryLength);</span><br><span class="line">                throw new TrinoException(QUERY_TEXT_TOO_LARGE, format(&quot;Query text length (%s) exceeds the maximum length (%s)&quot;, queryLength, maxQueryLength));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;通过安全认证的方式获取session</span><br><span class="line">            &#x2F;&#x2F; decode session</span><br><span class="line">            session &#x3D; sessionSupplier.createSession(queryId, sessionContext);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;校验一下配置，是否有执行权限</span><br><span class="line">            &#x2F;&#x2F; check query execute permissions</span><br><span class="line">            accessControl.checkCanExecuteQuery(sessionContext.getIdentity());</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;sql解析</span><br><span class="line">            &#x2F;&#x2F; prepare query</span><br><span class="line">            preparedQuery &#x3D; queryPreparer.prepareQuery(session, query);</span><br><span class="line"></span><br><span class="line">						&#x2F;&#x2F;选择资源组</span><br><span class="line">            &#x2F;&#x2F; select resource group</span><br><span class="line">            Optional&lt;String&gt; queryType &#x3D; getQueryType(preparedQuery.getStatement()).map(Enum::name);</span><br><span class="line">            SelectionContext&lt;C&gt; selectionContext &#x3D; resourceGroupManager.selectGroup(new SelectionCriteria(</span><br><span class="line">                    sessionContext.getIdentity().getPrincipal().isPresent(),</span><br><span class="line">                    sessionContext.getIdentity().getUser(),</span><br><span class="line">                    sessionContext.getIdentity().getGroups(),</span><br><span class="line">                    sessionContext.getSource(),</span><br><span class="line">                    sessionContext.getClientTags(),</span><br><span class="line">                    sessionContext.getResourceEstimates(),</span><br><span class="line">                    queryType));</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; apply system default session properties (does not override user set properties)</span><br><span class="line">            session &#x3D; sessionPropertyDefaults.newSessionWithDefaultProperties(session, queryType, selectionContext.getResourceGroupId());</span><br><span class="line"></span><br><span class="line">						&#x2F;&#x2F;分配查询</span><br><span class="line">            DispatchQuery dispatchQuery &#x3D; dispatchQueryFactory.createDispatchQuery(</span><br><span class="line">                    session,</span><br><span class="line">                    sessionContext.getTransactionId(),</span><br><span class="line">                    query,</span><br><span class="line">                    preparedQuery,</span><br><span class="line">                    slug,</span><br><span class="line">                    selectionContext.getResourceGroupId());</span><br><span class="line"></span><br><span class="line">            boolean queryAdded &#x3D; queryCreated(dispatchQuery);</span><br><span class="line">            if (queryAdded &amp;&amp; !dispatchQuery.isDone()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    resourceGroupManager.submit(dispatchQuery, selectionContext, dispatchExecutor);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Throwable e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; dispatch query has already been registered, so just fail it directly</span><br><span class="line">                    dispatchQuery.fail(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable throwable) &#123;</span><br><span class="line">            &#x2F;&#x2F; creation must never fail, so register a failed query in this case</span><br><span class="line">            if (session &#x3D;&#x3D; null) &#123;</span><br><span class="line">                session &#x3D; Session.builder(sessionPropertyManager)</span><br><span class="line">                        .setQueryId(queryId)</span><br><span class="line">                        .setIdentity(sessionContext.getIdentity())</span><br><span class="line">                        .setSource(sessionContext.getSource().orElse(null))</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line">            Optional&lt;String&gt; preparedSql &#x3D; Optional.ofNullable(preparedQuery).flatMap(PreparedQuery::getPrepareSql);</span><br><span class="line">            DispatchQuery failedDispatchQuery &#x3D; failedDispatchQueryFactory.createFailedDispatchQuery(session, query, preparedSql, Optional.empty(), throwable);</span><br><span class="line">            queryCreated(failedDispatchQuery);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>QueryPreparer委托SqlParser（createQueryInternal核心逻辑之一），进入到invokeParser，该方法对sql进行语法解析，通过visit模式，构建Ast语法树，Ast根据Sql解析出Query对象，封装为PreparedQuery。</li>
</ol>
<p>堆栈路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">io.trino.dispatcher.DispatchManager#createQueryInternal</span><br><span class="line">io.trino.execution.QueryPreparer#prepareQuery (io.trino.Session, java.lang.String)</span><br><span class="line">io.trino.sql.parser.SqlParser#createStatement</span><br><span class="line">io.trino.sql.parser.SqlParser#invokeParser</span><br></pre></td></tr></table></figure>

<p>核心方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private Node invokeParser(String name, String sql, Function&lt;SqlBaseParser, ParserRuleContext&gt; parseFunction, ParsingOptions parsingOptions)</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">        		&#x2F;&#x2F;通过antlr生成的词法解析</span><br><span class="line">            SqlBaseLexer lexer &#x3D; new SqlBaseLexer(new CaseInsensitiveStream(CharStreams.fromString(sql)));</span><br><span class="line">            CommonTokenStream tokenStream &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">            SqlBaseParser parser &#x3D; new SqlBaseParser(tokenStream);</span><br><span class="line">            initializer.accept(lexer, parser);</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            ...省略词法解析的异常监听</span><br><span class="line"></span><br><span class="line">            ParserRuleContext tree;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; first, try parsing with potentially faster SLL mode</span><br><span class="line">                parser.getInterpreter().setPredictionMode(PredictionMode.SLL);</span><br><span class="line">                tree &#x3D; parseFunction.apply(parser);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (ParseCancellationException ex) &#123;</span><br><span class="line">                &#x2F;&#x2F; if we fail, parse with LL mode</span><br><span class="line">                tokenStream.seek(0); &#x2F;&#x2F; rewind input stream</span><br><span class="line">                parser.reset();</span><br><span class="line"></span><br><span class="line">                parser.getInterpreter().setPredictionMode(PredictionMode.LL);</span><br><span class="line">                tree &#x3D; parseFunction.apply(parser);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">						&#x2F;&#x2F;解析生成Node</span><br><span class="line">            return new AstBuilder(parsingOptions).visit(tree);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (StackOverflowError e) &#123;</span><br><span class="line">            throw new ParsingException(name + &quot; is too large (stack overflow while parsing)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>DispatchQueryFactory分配查询（createQueryInternal核心逻辑之一），主要有2个核心逻辑，a) 注册SqlQueryExecution构造方法，b) 构造LocalDispatchQuery，并注册钩子方法SqlQueryManager::createQuery。</li>
</ol>
<p>堆栈路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.trino.dispatcher.DispatchManager#createQueryInternal</span><br><span class="line">io.trino.dispatcher.DispatchQueryFactory#createDispatchQuery</span><br><span class="line">io.trino.dispatcher.LocalDispatchQuery</span><br></pre></td></tr></table></figure>

<p>核心方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">io.trino.dispatcher.LocalDispatchQueryFactory#createDispatchQuery</span><br><span class="line">public DispatchQuery createDispatchQuery(</span><br><span class="line">            Session session,</span><br><span class="line">            Optional&lt;TransactionId&gt; existingTransactionId,</span><br><span class="line">            String query,</span><br><span class="line">            PreparedQuery preparedQuery,</span><br><span class="line">            Slug slug,</span><br><span class="line">            ResourceGroupId resourceGroup)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 启动 查询状态机</span><br><span class="line">        WarningCollector warningCollector &#x3D; warningCollectorFactory.create();</span><br><span class="line">        PlanOptimizersStatsCollector planOptimizersStatsCollector &#x3D; new PlanOptimizersStatsCollector(queryReportedRuleStatsLimit);</span><br><span class="line">        QueryStateMachine stateMachine &#x3D; QueryStateMachine.begin(</span><br><span class="line">                existingTransactionId,</span><br><span class="line">                query,</span><br><span class="line">                preparedQuery.getPrepareSql(),</span><br><span class="line">                session,</span><br><span class="line">                locationFactory.createQueryLocation(session.getQueryId()),</span><br><span class="line">                resourceGroup,</span><br><span class="line">                isTransactionControlStatement(preparedQuery.getStatement()),</span><br><span class="line">                transactionManager,</span><br><span class="line">                accessControl,</span><br><span class="line">                &#x2F;&#x2F; limit the number of state change listener callback threads for each query</span><br><span class="line">                new BoundedExecutor(executor, maxStateMachineThreadsPerQuery),</span><br><span class="line">                metadata,</span><br><span class="line">                warningCollector,</span><br><span class="line">                planOptimizersStatsCollector,</span><br><span class="line">                getQueryType(preparedQuery.getStatement()),</span><br><span class="line">                faultTolerantExecutionExchangeEncryptionEnabled,</span><br><span class="line">                version);</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; 监控</span><br><span class="line">        queryMonitor.queryCreatedEvent(stateMachine.getBasicQueryInfo(Optional.empty()));</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; 注册SqlQueryExecution工厂类</span><br><span class="line">        ListenableFuture&lt;QueryExecution&gt; queryExecutionFuture &#x3D; executor.submit(() -&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 省略</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                return queryExecutionFactory.createQueryExecution(preparedQuery, stateMachine, slug, warningCollector, planOptimizersStatsCollector);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable e) &#123; </span><br><span class="line">            	&#x2F;&#x2F; 省略异常处理</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; 注册 createQuery钩子方法</span><br><span class="line">        return new LocalDispatchQuery(</span><br><span class="line">                stateMachine,</span><br><span class="line">                queryExecutionFuture,</span><br><span class="line">                queryMonitor,</span><br><span class="line">                clusterSizeMonitor,</span><br><span class="line">                executor,</span><br><span class="line">                queryManager::createQuery);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>DispatchQueryFactory分配查询（createQueryInternal核心逻辑之一），经过一系列回调，触发钩子函数SqlQueryManager::createQuery，最终由SqlQueryExecute.start()开启调度执行。</li>
</ol>
<p>堆栈路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">io.trino.dispatcher.DispatchManager#createQueryInternal</span><br><span class="line">io.trino.execution.resourcegroups.ResourceGroupManager#submit</span><br><span class="line">io.trino.execution.resourcegroups.InternalResourceGroup#run</span><br><span class="line">io.trino.execution.resourcegroups.InternalResourceGroup#startInBackground</span><br><span class="line">io.trino.dispatcher.LocalDispatchQuery#startWaitingForResources</span><br><span class="line">io.trino.dispatcher.LocalDispatchQuery#waitForMinimumWorkers</span><br><span class="line">io.trino.dispatcher.LocalDispatchQuery#startExecution</span><br></pre></td></tr></table></figure>

<p>核心方法 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">io.trino.dispatcher.LocalDispatchQuery#startExecution</span><br><span class="line">private void startExecution(QueryExecution queryExecution)</span><br><span class="line">    &#123;</span><br><span class="line">        if (stateMachine.transitionToDispatching()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            		&#x2F;&#x2F; 调用前面注册的钩子函数</span><br><span class="line">                querySubmitter.accept(queryExecution);</span><br><span class="line">                if (notificationSentOrGuaranteed.compareAndSet(false, true)) &#123;</span><br><span class="line">                    queryExecution.addFinalQueryInfoListener(queryMonitor::queryCompletedEvent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable t) &#123;</span><br><span class="line">            		&#x2F;&#x2F;省略异常处理</span><br><span class="line">            &#125;</span><br><span class="line">            finally &#123;</span><br><span class="line">                submitted.set(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>钩子函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">io.trino.execution.SqlQueryManager#createQuery</span><br><span class="line">public void createQuery(QueryExecution queryExecution)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 省略校验，以及queryTracker执行日志的过期处理</span><br><span class="line"></span><br><span class="line">        try (SetThreadName _ &#x3D; new SetThreadName(&quot;Query-%s&quot;, queryExecution.getQueryId())) &#123;</span><br><span class="line">            try (var ignoredStartScope &#x3D; scopedSpan(tracer.spanBuilder(&quot;query-start&quot;)</span><br><span class="line">                    .setParent(Context.current().with(queryExecution.getSession().getQuerySpan()))</span><br><span class="line">                    .startSpan())) &#123;</span><br><span class="line">                &#x2F;&#x2F; 执行查询</span><br><span class="line">                queryExecution.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>开始调度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io.trino.execution.SqlQueryExecution#start</span><br><span class="line">public void start()</span><br><span class="line">    &#123; </span><br><span class="line">    	&#x2F;&#x2F;省略具体执行</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主要类</li>
</ul>
<p>DispatchManager</p>
<h4 id="生成逻辑执行计划"><a href="#生成逻辑执行计划" class="headerlink" title="生成逻辑执行计划"></a>生成逻辑执行计划</h4><p><img src="/2023/05/11/3_Presto/image12.png" alt="image-2022062517"></p>
<ul>
<li>主要逻辑</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">io.trino.execution.SqlQueryExecution#start</span><br><span class="line">public void start()</span><br><span class="line">    &#123;</span><br><span class="line">        try (SetThreadName _ &#x3D; new SetThreadName(&quot;Query-%s&quot;, stateMachine.getQueryId())) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            		&#x2F;&#x2F; 执行状态变更：  -&gt; planning</span><br><span class="line">                if (!stateMachine.transitionToPlanning()) &#123;</span><br><span class="line">                    &#x2F;&#x2F; query already started or finished</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">								&#x2F;&#x2F; 省略注册执行引擎状态变更监听</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 1 构造逻辑执行计划</span><br><span class="line">                    CachingTableStatsProvider tableStatsProvider &#x3D; new CachingTableStatsProvider(plannerContext.getMetadata(), getSession());</span><br><span class="line">                    PlanRoot plan &#x3D; planQuery(tableStatsProvider);</span><br><span class="line">                    </span><br><span class="line">                    &#x2F;&#x2F; 省略加速特性-动态过滤</span><br><span class="line">                    </span><br><span class="line">                    &#x2F;&#x2F; 2 执行计划分配</span><br><span class="line">                    planDistribution(plan, tableStatsProvider);</span><br><span class="line">                &#125;</span><br><span class="line">                finally &#123;</span><br><span class="line">                    synchronized (planningThread) &#123;</span><br><span class="line">                        planningThread.set(null);</span><br><span class="line">                        &#x2F;&#x2F; Clear the interrupted flag in case there was a race condition where</span><br><span class="line">                        &#x2F;&#x2F; the planning thread was interrupted right after planning completes above</span><br><span class="line">                        Thread.interrupted();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                tableExecuteContextManager.registerTableExecuteContextForQuery(getQueryId());</span><br><span class="line"></span><br><span class="line">								&#x2F;&#x2F; 执行状态变更： ? -&gt; planning ，?大概率是planning</span><br><span class="line">                if (!stateMachine.transitionToStarting()) &#123;</span><br><span class="line">                    &#x2F;&#x2F; query already started or finished</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; if query is not finished, start the scheduler, otherwise cancel it</span><br><span class="line">                QueryScheduler scheduler &#x3D; queryScheduler.get();</span><br><span class="line"></span><br><span class="line">								&#x2F;&#x2F; 执行状态判断：finished or faild</span><br><span class="line">                if (!stateMachine.isDone()) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 3. 开始执行</span><br><span class="line">                    scheduler.start();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable e) &#123;</span><br><span class="line">                fail(e);</span><br><span class="line">                throwIfInstanceOf(e, Error.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>构造逻辑执行计划：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">io.trino.execution.SqlQueryExecution#doPlanQuery</span><br><span class="line">private PlanRoot doPlanQuery(CachingTableStatsProvider tableStatsProvider)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 省略logicalPlanner构造函数</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 1 逻辑执行计划解析，验证，收集cost和表信息</span><br><span class="line">        Plan plan &#x3D; logicalPlanner.plan(analysis);</span><br><span class="line">        queryPlan.set(plan);</span><br><span class="line">	</span><br><span class="line">        &#x2F;&#x2F; 2. 逻辑查询计划分片</span><br><span class="line">        SubPlan fragmentedPlan;</span><br><span class="line">        try (var _ &#x3D; scopedSpan(tracer, &quot;fragment-plan&quot;)) &#123;</span><br><span class="line">            fragmentedPlan &#x3D; planFragmenter.createSubPlans(stateMachine.getSession(), plan, false, stateMachine.getWarningCollector());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3. 提取input和output，包装执行计划树PlanRoot</span><br><span class="line">        try (var _ &#x3D; scopedSpan(tracer, &quot;extract-inputs&quot;)) &#123;</span><br><span class="line">            stateMachine.setInputs(new InputExtractor(plannerContext.getMetadata(), stateMachine.getSession()).extractInputs(fragmentedPlan));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stateMachine.setOutput(analysis.getTarget());</span><br><span class="line"></span><br><span class="line">        boolean explainAnalyze &#x3D; analysis.getStatement() instanceof ExplainAnalyze;</span><br><span class="line">        return new PlanRoot(fragmentedPlan, !explainAnalyze);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>执行计划分配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">io.trino.execution.SqlQueryExecution#planDistribution</span><br><span class="line">private void planDistribution(PlanRoot plan, CachingTableStatsProvider tableStatsProvider)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; if query was canceled, skip creating scheduler</span><br><span class="line">        if (stateMachine.isDone()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取逻辑查询计划分片</span><br><span class="line">        PlanFragment rootFragment &#x3D; plan.getRoot().getFragment();</span><br><span class="line">        stateMachine.setColumns(</span><br><span class="line">                ((OutputNode) rootFragment.getRoot()).getColumnNames(),</span><br><span class="line">                rootFragment.getTypes());</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; 构造查询调度，存入queryScheduler</span><br><span class="line">        RetryPolicy retryPolicy &#x3D; getRetryPolicy(getSession());</span><br><span class="line">        QueryScheduler scheduler &#x3D; switch (retryPolicy) &#123;</span><br><span class="line">            case QUERY, NONE -&gt; new PipelinedQueryScheduler(</span><br><span class="line">                    stateMachine,</span><br><span class="line">                    plan.getRoot(),</span><br><span class="line">                    nodePartitioningManager,</span><br><span class="line">                    nodeScheduler,</span><br><span class="line">                    remoteTaskFactory,</span><br><span class="line">                    plan.isSummarizeTaskInfos(),</span><br><span class="line">                    scheduleSplitBatchSize,</span><br><span class="line">                    queryExecutor,</span><br><span class="line">                    schedulerExecutor,</span><br><span class="line">                    failureDetector,</span><br><span class="line">                    nodeTaskMap,</span><br><span class="line">                    executionPolicy,</span><br><span class="line">                    tracer,</span><br><span class="line">                    schedulerStats,</span><br><span class="line">                    dynamicFilterService,</span><br><span class="line">                    tableExecuteContextManager,</span><br><span class="line">                    plannerContext.getMetadata(),</span><br><span class="line">                    splitSourceFactory,</span><br><span class="line">                    coordinatorTaskManager);</span><br><span class="line">            case TASK -&gt; new EventDrivenFaultTolerantQueryScheduler(</span><br><span class="line">                    stateMachine,</span><br><span class="line">                    plannerContext.getMetadata(),</span><br><span class="line">                    remoteTaskFactory,</span><br><span class="line">                    taskDescriptorStorage,</span><br><span class="line">                    eventDrivenTaskSourceFactory,</span><br><span class="line">                    plan.isSummarizeTaskInfos(),</span><br><span class="line">                    nodeTaskMap,</span><br><span class="line">                    queryExecutor,</span><br><span class="line">                    schedulerExecutor,</span><br><span class="line">                    tracer,</span><br><span class="line">                    schedulerStats,</span><br><span class="line">                    partitionMemoryEstimatorFactory,</span><br><span class="line">                    outputStatsEstimatorFactory,</span><br><span class="line">                    nodePartitioningManager,</span><br><span class="line">                    exchangeManagerRegistry.getExchangeManager(),</span><br><span class="line">                    nodeAllocatorService,</span><br><span class="line">                    failureDetector,</span><br><span class="line">                    dynamicFilterService,</span><br><span class="line">                    taskExecutionStats,</span><br><span class="line">                    new AdaptivePlanner(</span><br><span class="line">                            stateMachine.getSession(),</span><br><span class="line">                            plannerContext,</span><br><span class="line">                            adaptivePlanOptimizers,</span><br><span class="line">                            planFragmenter,</span><br><span class="line">                            DISTRIBUTED_PLAN_SANITY_CHECKER,</span><br><span class="line">                            stateMachine.getWarningCollector(),</span><br><span class="line">                            planOptimizersStatsCollector,</span><br><span class="line">                            tableStatsProvider),</span><br><span class="line">                    stageExecutionStats,</span><br><span class="line">                    plan.getRoot());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        queryScheduler.set(scheduler);</span><br><span class="line">        stateMachine.addQueryInfoStateChangeListener(queryInfo -&gt; &#123;</span><br><span class="line">            if (queryInfo.isFinalQueryInfo()) &#123;</span><br><span class="line">                queryScheduler.set(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Sql解析成PlanNode</p>
<p>主要通过RelationPlanner继承AstVisitor，使用Visit模式，通过RelationPlanner的visitQuery，visitQuerySpecification等构造RelationPlan。</p>
<p>抽象元素：Node</p>
<p>具体元素是主要有：Query，QuerySpecification</p>
<p>抽象访问者：AstVisitor</p>
<p>具体访问者：RelationPlanner</p>
<p>存储元素结构：RelationPlan</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">io.trino.sql.planner.QueryPlanner#plan(io.trino.sql.tree.Query)</span><br><span class="line">io.trino.sql.planner.QueryPlanner#plan(io.trino.sql.tree.QuerySpecification)</span><br><span class="line">public RelationPlan plan(QuerySpecification node)</span><br><span class="line">    &#123;</span><br><span class="line">        PlanBuilder builder &#x3D; planFrom(node);</span><br><span class="line"></span><br><span class="line">        builder &#x3D; filter(builder, analysis.getWhere(node), node);</span><br><span class="line">        builder &#x3D; aggregate(builder, node);</span><br><span class="line">        builder &#x3D; filter(builder, analysis.getHaving(node), node);</span><br><span class="line">        builder &#x3D; planWindowFunctions(node, builder, ImmutableList.copyOf(analysis.getWindowFunctions(node)));</span><br><span class="line">        builder &#x3D; planWindowMeasures(node, builder, ImmutableList.copyOf(analysis.getWindowMeasures(node)));</span><br><span class="line">        </span><br><span class="line">        ..省略</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过PlanOptimizer优化PlanNode，使用Visit模式，优化PlanNode</p>
<p>抽象元素：PlanNode</p>
<p>具体元素是主要有：ProjectNode，JoinNode等</p>
<p>抽象访问者：PlanVisitor</p>
<p>具体访问者：IterativeOptimizer，PredicatePushDown等内部类Rewriter</p>
<p>存储元素结构：LogicalPlanner</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">io.trino.sql.planner.LogicalPlanner#runOptimizer</span><br><span class="line">private PlanNode runOptimizer(PlanNode root, TableStatsProvider tableStatsProvider, PlanOptimizer optimizer)</span><br><span class="line">    &#123;</span><br><span class="line">        PlanNode result;</span><br><span class="line">        try (var _ &#x3D; optimizerSpan(optimizer)) &#123;</span><br><span class="line">            &#x2F;&#x2F;具体优化</span><br><span class="line">            result &#x3D; optimizer.optimize(root, new PlanOptimizer.Context(session, symbolAllocator, idAllocator, warningCollector, planOptimizersStatsCollector, tableStatsProvider, RuntimeInfoProvider.noImplementation()));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;打印日志</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>相对重要的优化策略</p>
<p>AddExchanges</p>
<p>委托在StatsRecordingPlanOptimizer优化器中进行优化。优化的策略如下：</p>
<p>对于AggregationNode，将其拆分成局部聚合和最终聚合(Final、partial、single)，在两个聚合之间增加ExchangeNode</p>
<p>对于三种类型的Join，根据数据表特性会出现（有group by字段时增加一个ExchangeNode，无左右分别增加ExchangeNode）</p>
<p>对于窗口函数下增加ExchangeNode</p>
<p>对于count-distinct对增加ExchangeNode</p>
<p>分片逻辑执行计划</p>
<p>SubPlan，单个分片的执行计划。</p>
<p>Fragment：维护单个分片的相关信息，如分区描述信息，分居数据表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public SubPlan createSubPlans(</span><br><span class="line">            Session session,</span><br><span class="line">            Plan plan,</span><br><span class="line">            boolean forceSingleNode,</span><br><span class="line">            WarningCollector warningCollector,</span><br><span class="line">            PlanFragmentIdAllocator idAllocator,</span><br><span class="line">            PartitioningScheme outputPartitioningScheme,</span><br><span class="line">            Map&lt;ExchangeSourceId, SubPlan&gt; unchangedSubPlans)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 准备分片器</span><br><span class="line">        Fragmenter fragmenter &#x3D; new Fragmenter(</span><br><span class="line">                session,</span><br><span class="line">                metadata,</span><br><span class="line">                functionManager,</span><br><span class="line">                plan.getStatsAndCosts(),</span><br><span class="line">                activeCatalogs,</span><br><span class="line">                languageScalarFunctions,</span><br><span class="line">                idAllocator,</span><br><span class="line">                unchangedSubPlans);</span><br><span class="line">        FragmentProperties properties &#x3D; new FragmentProperties(outputPartitioningScheme);</span><br><span class="line">        if (forceSingleNode || isForceSingleNodeOutput(session)) &#123;</span><br><span class="line">            properties &#x3D; properties.setSingleNodeDistribution();</span><br><span class="line">        &#125;</span><br><span class="line">        PlanNode root &#x3D; SimplePlanRewriter.rewriteWith(fragmenter, plan.getRoot(), properties);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 构造子执行计划</span><br><span class="line">        SubPlan subPlan &#x3D; fragmenter.buildRootFragment(root, properties);</span><br><span class="line">        subPlan &#x3D; reassignPartitioningHandleIfNecessary(session, subPlan);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 省略后置校验</span><br><span class="line">        </span><br><span class="line">        return subPlan;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>主要类</li>
</ul>
<h4 id="分布式执行"><a href="#分布式执行" class="headerlink" title="分布式执行"></a>分布式执行</h4><blockquote>
<p>以Query，None重试策略为例，默认为None</p>
</blockquote>
<p><img src="/2023/05/11/3_Presto/image13.png" alt="image-2022062517"></p>
<ul>
<li>核心逻辑</li>
</ul>
<p>将SubPlan执行计划，构造成不同的阶段调度，异步执行调度并返回调度结果。</p>
<ul>
<li>核心类</li>
</ul>
<p>QueryStateMachine，查询状态引擎，主要维护回调事件，查询进度状态。</p>
<p>SqlQueryExecution，构造Pipelined查询调度器，串联构造相应的Scheduler，StageExecution，并异步执行调度。</p>
<p>PipelinedQueryScheduler（实现QueryScheduler），具体的调度实现，内部构造StageManager，CoordinatorStagesScheduler（协调者调度），接收SqlQueryExecution的start指令后，协调者schedule调度开始，同时分布式调度委托给DistributedStagesScheduler，负责schedule调度。当DistributedStagesScheduler构造完成后，调用StageScheduler的start开始调度，schedule尝试执行调度并返回ScheduleResult（有的调度在start已经异步执行，schedule阶段可能能返回结果），循环schedule阶段，直到所有阶段均获取到数据。</p>
<p>StageManager，阶段管理，由PipelinedQueryScheduler构建。将SubPlan转换成SqlStage，便于后续执行。</p>
<p>DistributedStagesScheduler，PipelinedQueryScheduler的内部类，具体完成分阶段的分布式查询。在构造期间，1） 会根据SqlStage构造StageExecution（如PipelinedStageExecution，实现StageExecution接口）；2）紧接着构造StageScheduler，根据split切割情况，参数配置等，初始化FixedSourcePartitionedScheduler、MultiSourcePartitionedScheduler（实现StageScheduler接口）；3）进行初始化initialize，注册回调。</p>
<h4 id="调度及结果回写"><a href="#调度及结果回写" class="headerlink" title="调度及结果回写"></a>调度及结果回写</h4><ul>
<li>主要逻辑</li>
</ul>
<p>拉取数据方</p>
<ol>
<li>在Query类的create方法中，给SqlQueryManager注册OutputInfoListener，把ExchangeDataSource.addInput方法传入，作为数据写入的回调方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io.trino.server.protocol.Query#create</span><br><span class="line">result.queryManager.setOutputInfoListener(result.getQueryId(), result::setQueryOutputInfo)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>ExecutingStatementResource接收到http查询数据请求后，异步调用protocol.Query的waitForResults方法，等待数据填充；</p>
</li>
<li><p>protocol.query::waitForResults中，注册stateChange事件，并等待一定时间；stateChange事件内部是等待exchangeDataSource状态完成；</p>
</li>
<li><p>当stateChange触发时，调用钩子函数getNextResult，在getNextResult中，SqlQueryManager的getResultQueryInfo方法获取查询结。1) 如果ResultQueryInfo状态为Start时，会尝试调用exchangeDataSource.pollPage获取数据。2）如果ResultQueryInfo状态没有完成或构造完成，且状态正常，返回数据不为空，则构造nextUri及token、http返回数据，等待下次请求尝试获取后续数据。</p>
</li>
</ol>
<p>提供数据方</p>
<ol>
<li>QueryStateMachine调用begin后，经过分布式执行，这里分为2类TaskLifecycleListener，分阶段构造，先初始化CoordinatorStagesScheduler，1）CoordinatorStagesScheduler构造的QueryOutputTaskLifecycleListener，2）PipelinedStageStateMachine的匿名内部类。</li>
<li>PipelinedStageExecution陆续调用scheduleTask调度方法，在scheduleTask方法中，会调用RemoteTask的start方法，开启请求后，会注册线程池，异步等待结果。等待上游数据提供好后，将请求uri通过http写入状态，并更新exchangeDataSource。主要调度方法参考下列注释</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">io.trino.execution.scheduler.PipelinedStageExecution#scheduleTask</span><br><span class="line">public synchronized Optional&lt;RemoteTask&gt; scheduleTask(</span><br><span class="line">            InternalNode node,</span><br><span class="line">            int partition,</span><br><span class="line">            Multimap&lt;PlanNodeId, Split&gt; initialSplits)</span><br><span class="line">    &#123;</span><br><span class="line">    		&#x2F;&#x2F; 省略前置校验</span><br><span class="line">    		</span><br><span class="line">				&#x2F;&#x2F; 准备缓冲区数据</span><br><span class="line">        OutputBuffers outputBuffers &#x3D; outputBufferManagers.get(stage.getFragment().getId()).getOutputBuffers();</span><br><span class="line"></span><br><span class="line">        Optional&lt;RemoteTask&gt; optionalTask &#x3D; stage.createTask(</span><br><span class="line">                node,</span><br><span class="line">                partition,</span><br><span class="line">                attempt,</span><br><span class="line">                bucketToPartition,</span><br><span class="line">                outputBuffers,</span><br><span class="line">                initialSplits,</span><br><span class="line">                ImmutableSet.of(),</span><br><span class="line">                Optional.empty(),</span><br><span class="line">                false);</span><br><span class="line"></span><br><span class="line">        if (optionalTask.isEmpty()) &#123;</span><br><span class="line">            return Optional.empty();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RemoteTask task &#x3D; optionalTask.get();</span><br><span class="line"> 				</span><br><span class="line"> 				&#x2F;&#x2F;省略一些准备工作</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; 分配下游分片，这里会尝试触发更新协调者协调者缓冲区数据</span><br><span class="line">        task.addSplits(exchangeSplits.build());</span><br><span class="line">        completeSources.forEach(task::noMoreSplits);</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; 注册一些钩子函数</span><br><span class="line">        task.addStateChangeListener(this::updateTaskStatus);</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; 正式开始调度，包括写入协调者缓冲区数据，获取任务状态</span><br><span class="line">        task.start();</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; 调用exchangeDataSource.pollPage钩子函数，将请求地址push到队列，拉取数据方获取到请求地址后，调用Get请求&#x2F;v1&#x2F;task&#x2F;&#123;taskId&#125;&#x2F;result，获取缓冲区数据</span><br><span class="line">        taskLifecycleListener.taskCreated(stage.getFragment().getId(), task);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 更新上游缓冲区（提供数据的为上游，典型的上游为TableScan）</span><br><span class="line">        OutputBufferId outputBufferId &#x3D; new OutputBufferId(task.getTaskId().getPartitionId());</span><br><span class="line">        updateSourceTasksOutputBuffers(outputBufferManager -&gt; outputBufferManager.addOutputBuffer(outputBufferId));</span><br><span class="line"></span><br><span class="line">        return Optional.of(task);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主要类</li>
</ul>
<p>io.trino.dispatcher.LocalDispatchQueryFactory#createDispatchQuery<br>io.trino.execution.SqlQueryExecution.SqlQueryExecutionFactory#createQueryExecution<br>io.trino.execution.SqlQueryManager#createQuery<br>io.trino.execution.SqlQueryExecution#start</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="Visit模式"><a href="#Visit模式" class="headerlink" title="Visit模式"></a>Visit模式</h3><h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3><h1 id="工作实践"><a href="#工作实践" class="headerlink" title="工作实践"></a>工作实践</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通过对查询计划的分析，我们了解到以下几点信息</p>
<ol>
<li>执行计划会在Presto服务端进行缓存，并提供页面查询，但查询结果随Presto服务重启丢失，且有存活有效期，默认为5分钟</li>
<li>作为查询引擎，必然会对sql进行优化改写，有一些常用的聚合下推，字段过滤，连接优化等。但均基于规则，只有部分数据源支持基于代价优化，可以通过explain查看执行计划</li>
<li>数据是通过客户端不断发起请求，滚动获取数据</li>
<li>查询结果是经过多个Worker的结果组合而成，尽量减少最小粒度的查询能有效降低网络传输，提高查询性能</li>
</ol>
<h2 id="慢查询监控"><a href="#慢查询监控" class="headerlink" title="慢查询监控"></a>慢查询监控</h2><p>根据业务定义，这里我们认为超过5分钟的查询即为慢查询</p>
<p>定位慢查询，首先需要能够收集慢查询的信息，这里Presto提供了 <a href="https://trino.io/docs/current/admin/event-listeners-http.html" target="_blank" rel="noopener">EventListener</a> ，Presto会将执行计划通过http发送到指定url，收集到执行计划后，我们可以将执行耗时及查询id输出到grafana上，以便后续分析，监控页面如下：</p>
<p><img src="/2023/05/11/3_Presto/image7.png" alt="image-202206251715403"></p>
<ul>
<li>查询计划可视化</li>
</ul>
<p>通过EventListener收集到的执行计划，我们已经可以精准定位到某一条sql，但相同的查询，在不同集群状况下执行效果不同，为了能够精准判断当时的执行结果，我们需要能够重现执行计划。由于执行计划是一个较大的Json体，为了能更直观的查看执行计划，可以通过适当改写源码的执行计划展示逻辑，读取本地执行计划文件，以便输出展示。</p>
<p>后端魔改的类：io.trino.server.ui.UiQueryResource#getQueryInfo</p>
<p>前端魔改的js：webapp/dist/plan.js</p>
<ul>
<li>集群运行状态分析<ul>
<li>分区是否合理，是否倾斜</li>
<li>内存设置是否合理</li>
<li>队列是否空闲</li>
</ul>
</li>
</ul>
<h2 id="常用优化策略"><a href="#常用优化策略" class="headerlink" title="常用优化策略"></a>常用优化策略</h2><ul>
<li>Sql优化</li>
</ul>
<p>​        优化手段也比较多，官网和网上都讲的比较详细，例如大表放左侧，只查询必要字段，orderBy和Limit共同使用，少用Distinct，命中分区键等。</p>
<p>​        方式有很多种，大体上是基于减少单节点的无效操作为主，这样可以有效降低内存和cpu的消耗。由于我们采用的是Presto+kudu的方式，无法支持基于Cost的优化，优化思路基本集中在合理设计分区，减少扫描量上。更进一步优化需要从业务侧入手，控制高频低价值的查询。</p>
<ul>
<li>数据存储优化<ul>
<li>数据存储分区合理，在尽量不产生数据倾斜的情况下，结合业务使用场景进行分区。</li>
<li>尽可能提前计算数据，减少查询时的聚合量</li>
<li>冷数据做好备份，控制数据总量</li>
</ul>
</li>
</ul>
<h1 id="kudu分区裁剪效果"><a href="#kudu分区裁剪效果" class="headerlink" title="kudu分区裁剪效果"></a>kudu分区裁剪效果</h1><p>presto在生成物理执行计划之前，会创建kudu扫描token（scan-token），用来生成split，并行扫描，此时通过kudu的client，会根据剪纸效果，指定对应的driver，同时指定对应的tabletId，代码路径</p>
<p>物理执行计划生成：</p>
<p>io.prestosql.execution.SqlQueryExecution#planDistribution</p>
<p>io.prestosql.sql.planner.DistributedExecutionPlanner#plan</p>
<p>io.prestosql.sql.planner.DistributedExecutionPlanner#doPlan（生成splitSources）</p>
<p>io.prestosql.sql.planner.plan.ProjectNode#accept</p>
<p>io.prestosql.sql.planner.DistributedExecutionPlanner.Visitor#visitScanAndFilter</p>
<p>io.prestosql.split.SplitManager#getSplits</p>
<p>io.prestosql.plugin.kudu.KuduClientSession#buildKuduSplits（已经获取到指定的tabletId，便于后续生成KuduScanner）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;KuduSplit&gt; buildKuduSplits(KuduTableHandle tableHandle)</span><br><span class="line">    &#123;</span><br><span class="line">        KuduTable table &#x3D; tableHandle.getTable(this);</span><br><span class="line">        final int primaryKeyColumnCount &#x3D; table.getSchema().getPrimaryKeyColumnCount();</span><br><span class="line">        &#x2F;&#x2F;生成scanToken</span><br><span class="line">        KuduScanToken.KuduScanTokenBuilder builder &#x3D; client.newScanTokenBuilder(table);</span><br><span class="line"></span><br><span class="line">        TupleDomain&lt;ColumnHandle&gt; constraint &#x3D; tableHandle.getConstraint();</span><br><span class="line">        if (!addConstraintPredicates(table, builder, constraint)) &#123;</span><br><span class="line">            return ImmutableList.of();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Optional&lt;List&lt;ColumnHandle&gt;&gt; desiredColumns &#x3D; tableHandle.getDesiredColumns();</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; columnIndexes;</span><br><span class="line">        &#x2F;&#x2F;省略获取列过程</span><br><span class="line"></span><br><span class="line">        builder.setProjectedColumnIndexes(columnIndexes);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取每个tablet的scan</span><br><span class="line">        List&lt;KuduScanToken&gt; tokens &#x3D; builder.build();</span><br><span class="line">        return tokens.stream()</span><br><span class="line">                .map(token -&gt; toKuduSplit(tableHandle, token, primaryKeyColumnCount))</span><br><span class="line">                .collect(toImmutableList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>把Split带入到stage，开始调度</p>
<p>io.prestosql.execution.scheduler.SqlQueryScheduler#createSqlQueryScheduler</p>
<p>io.prestosql.execution.scheduler.SqlQueryScheduler#createStages</p>
<p>从stage中取出调度任务，开始执行</p>
<p>io.prestosql.execution.scheduler.SqlQueryScheduler#schedule</p>
<p>io.prestosql.execution.scheduler.StageScheduler#schedule</p>
<p>io.prestosql.execution.SqlStageExecution#scheduleSplits</p>
<p>利用PlanFragment构建Map&lt;PlanNodeId, SplitSource&gt;的关系，在找到Map&lt;PlanNodeId, TableInfo&gt; 的关系，将这个关系保存在StageExecutionPlan中</p>
<p>最后将调度结果存入执行计划缓存，以便页面观看</p>
<p><img src="/2023/05/11/3_Presto/image9.png" alt="image-202206251715403"></p>
<h1 id="奇怪的坑"><a href="#奇怪的坑" class="headerlink" title="奇怪的坑"></a>奇怪的坑</h1><h2 id="本地调试启动死循环"><a href="#本地调试启动死循环" class="headerlink" title="本地调试启动死循环"></a>本地调试启动死循环</h2><ul>
<li>现象：</li>
</ul>
<p>本地用openjdk17，21，22启动时trino-server-dev服务（trino版本为438），启动前会校验jvm的参数，经过堆栈追踪，发现程序一直卡在以下方法</p>
<p>org.openjdk.jol.vm.sa.ServiceabilityAgentSupport#callAgent(org.openjdk.jol.vm.sa.Task, boolean, org.openjdk.jol.vm.sa.ServiceabilityAgentSupport.AgentStyle)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">agentProcess &#x3D; (new ProcessBuilder(args)).start();</span><br><span class="line">Request request &#x3D; new Request(this.processId, processor, 5000);</span><br><span class="line">InputStream is &#x3D; agentProcess.getInputStream();</span><br><span class="line">OutputStream os &#x3D; agentProcess.getOutputStream();</span><br><span class="line">InputStream es &#x3D; agentProcess.getErrorStream();</span><br><span class="line">out &#x3D; new ObjectOutputStream(os);</span><br><span class="line">out.writeObject(request);</span><br><span class="line">out.flush();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;卡在这里</span><br><span class="line">int exitCode &#x3D; agentProcess.waitFor();</span><br><span class="line"></span><br><span class="line">agentProcess &#x3D; null;</span><br><span class="line">err &#x3D; new BufferedReader(new InputStreamReader(es));</span><br></pre></td></tr></table></figure>

<ul>
<li>处理过程：</li>
</ul>
<p>经过各种排查，在jdk的bug管理中找到蛛丝马迹，记录里表示，某使用者，用jol-0.17（也是trino依赖的版本），jdk21运行时，发现运行到attachMethod.invoke(agent, (int) request.getProcessId()); mac会崩溃，重启多次无效。另一个大神排查表示，怀疑是连接SA有问题，可以使用参数调过连接SA</p>
<p>链接如下：</p>
<p><a href="https://bugs.openjdk.org/browse/CODETOOLS-7903447?jql=resolution%20in%20(Unresolved%2C%20Fixed)%20AND%20component%20%3D%20tools%20AND%20Subcomponent%20%3D%20jol%20AND%20text%20~%20%22mac%22" target="_blank" rel="noopener">https://bugs.openjdk.org/browse/CODETOOLS-7903447?jql=resolution%20in%20(Unresolved%2C%20Fixed)%20AND%20component%20%3D%20tools%20AND%20Subcomponent%20%3D%20jol%20AND%20text%20~%20%22mac%22</a></p>
<ul>
<li>小结：</li>
</ul>
<p>最终在启动时，增加VM参数：-Djol.skipHotspotSAAttach=true。跳过连接SA。</p>
<h2 id="本地调试无法连接maven父项目"><a href="#本地调试无法连接maven父项目" class="headerlink" title="本地调试无法连接maven父项目"></a>本地调试无法连接maven父项目</h2><ul>
<li>现象：</li>
</ul>
<p>本地启动时，不管是trino父项目，还是子项目，均会报错提示无法连接到 <a href="http://repo.maven.apache.org/maven2" target="_blank" rel="noopener">http://repo.maven.apache.org/maven2</a> 但直接访问url<strong>貌似</strong>是可以的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] Non-resolvable import POM: Could not transfer artifact com.google.cloud:google-cloud-bigquerystorage-bom:pom:3.9.0 from&#x2F;to central (http:&#x2F;&#x2F;repo.maven.apache.org&#x2F;maven2): Failed to transfer http:&#x2F;&#x2F;repo.maven.apache.org&#x2F;maven2&#x2F;com&#x2F;google&#x2F;cloud&#x2F;google-cloud-bigquerystorage-bom&#x2F;3.9.0&#x2F;google-cloud-bigquerystorage-bom-3.9.0.pom. Error code 501, HTTPS Required @ com.google.cloud:google-cloud-bom:0.226.0, &#x2F;Users&#x2F;weiqian&#x2F;.m2&#x2F;repository&#x2F;com&#x2F;google&#x2F;cloud&#x2F;google-cloud-bom&#x2F;0.226.0&#x2F;google-cloud-bom-0.226.0.pom, line 179, column 19</span><br></pre></td></tr></table></figure>

<ul>
<li>处理过程：</li>
</ul>
<p>当pom中依赖父项目，且未配置relarelativePath时，父项目会默认从远程拉取。在org.apache.maven.model.building.DefaultModelBuilder#build(org.apache.maven.model.building.ModelBuildingRequest, java.util.Collection&lt;java.lang.String&gt;)构建过程中，会向远程下载父项目jar包。</p>
<p>但又因为airlift.resolver（版本1.6）项目在解析pom时，固定使用了http://，无法修改，参考<a href="https://github.com/airlift/resolver/pull/21" target="_blank" rel="noopener">git记录</a>。该committer申请了pr，但该项目太老了，最新一次发布在2019年，也没有将bugfix合并至最新版本。</p>
<p>而maven在很早的时候就不允许http下载，必须修改为https，因此下载失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">io.airlift.resolver.ArtifactResolver#getMavenProject</span><br><span class="line"></span><br><span class="line">PlexusContainer container &#x3D; container();</span><br><span class="line">org.apache.maven.repository.RepositorySystem lrs &#x3D; container.lookup(org.apache.maven.repository.RepositorySystem.class);</span><br><span class="line">ProjectBuilder projectBuilder &#x3D; container.lookup(ProjectBuilder.class);</span><br><span class="line">ProjectBuildingRequest request &#x3D; new DefaultProjectBuildingRequest();</span><br><span class="line">request.setSystemProperties(requiredSystemProperties());</span><br><span class="line">request.setRepositorySession(repositorySystemSession);</span><br><span class="line">request.setProcessPlugins(false);</span><br><span class="line">request.setLocalRepository(lrs.createDefaultLocalRepository());</span><br><span class="line">request.setRemoteRepositories(Arrays.asList(new ArtifactRepository[] &#123;lrs.createDefaultRemoteRepository()&#125;.clone()));</span><br><span class="line">ProjectBuildingResult result &#x3D; projectBuilder.build(pomFile, request);</span><br></pre></td></tr></table></figure>

<ul>
<li>小结：</li>
</ul>
<p>在pom中手动增加repository</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;name&gt;$&#123;project.artifactId&#125;&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;Trino&lt;&#x2F;description&gt;</span><br><span class="line">    &lt;url&gt;https:&#x2F;&#x2F;trino.io&lt;&#x2F;url&gt;</span><br><span class="line"></span><br><span class="line">    &lt;inceptionYear&gt;2012&lt;&#x2F;inceptionYear&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 新加的 --&gt;</span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;releases&gt;</span><br><span class="line">                &lt;enabled&gt;true&lt;&#x2F;enabled&gt;</span><br><span class="line">            &lt;&#x2F;releases&gt;</span><br><span class="line">            &lt;snapshots&gt;</span><br><span class="line">                &lt;enabled&gt;true&lt;&#x2F;enabled&gt;</span><br><span class="line">            &lt;&#x2F;snapshots&gt;</span><br><span class="line">            &lt;id&gt;nexus&lt;&#x2F;id&gt;</span><br><span class="line">            &lt;name&gt;nexus&lt;&#x2F;name&gt;</span><br><span class="line">            &lt;url&gt;https:&#x2F;&#x2F;repo.maven.apache.org&#x2F;maven2&lt;&#x2F;url&gt;</span><br><span class="line">        &lt;&#x2F;repository&gt;</span><br><span class="line">    &lt;&#x2F;repositories&gt;</span><br></pre></td></tr></table></figure>





<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><h1 id="阶段小结"><a href="#阶段小结" class="headerlink" title="阶段小结"></a>阶段小结</h1><p>本文主要以查询计划为分析点，介绍了Presto在查询执行和优化上的一些设计理念，以及分享实际工作中是如何定位和优化慢查询。Presto的源码模块结构较为清晰，且大量使用异步线程，提高查询性能。其中一些常用的查询优化手段，例如广播join，谓词下推，在其他的查询引擎中也都存在，对学习其他框架有参考作用，只有了解Presto的底层原理，才能更好的理解优化策略，更好的指导工作与学习。</p>
<h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/linjunjunjun/article/details/124831612" target="_blank" rel="noopener">presto查询流程</a></p>
<p><a href="https://blog.csdn.net/zhanyuanlin/article/details/131214028" target="_blank" rel="noopener">Presto(Trino)的逻辑执行计划和Fragment生成过程</a></p>
<p><a href="https://blog.csdn.net/zhanyuanlin/article/details/131343786" target="_blank" rel="noopener">Presto(Trino)分布式(物理)执行计划的生成和调度</a></p>
<h2 id="本地调试用表结构"><a href="#本地调试用表结构" class="headerlink" title="本地调试用表结构"></a>本地调试用表结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">创建表</span><br><span class="line">CREATE TABLE  memory.default.ncdp_dwb_channel_user_attribute_bos (</span><br><span class="line">   u_key varchar,</span><br><span class="line">   bos_id varchar,</span><br><span class="line">   name varchar</span><br><span class="line">);</span><br><span class="line">INSERT INTO memory.&quot;default&quot;.ncdp_dwb_channel_user_attribute_bos (u_key , bos_id,   name) VALUES(&#39;1000000027&#39; , &#39;4000180336837&#39;, &#39;张三&#39;);</span><br><span class="line">INSERT INTO memory.&quot;default&quot;.ncdp_dwb_channel_user_attribute_bos (u_key , bos_id,   name) VALUES(&#39;1000000028&#39; , &#39;4000180336837&#39;, &#39;李四&#39;);</span><br><span class="line">INSERT INTO memory.&quot;default&quot;.ncdp_dwb_channel_user_attribute_bos (u_key , bos_id,   name) VALUES(&#39;1000000029&#39; , &#39;4000180336837&#39;, &#39;王五&#39;);</span><br><span class="line"></span><br><span class="line">select * from memory.default.ncdp_dwb_channel_user_attribute_bos where u_key &#x3D;&#39;1000000029&#39;</span><br></pre></td></tr></table></figure>


                    
                </div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                    </div>
                    <div>
                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/2023/09/23/MQ%E9%80%89%E5%9E%8B%E6%AF%94%E8%BE%83/"
                                   title="MQ选型比较"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">MQ选型比较</span>
                                        <span class="post-nav-item">上一篇</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/2023/04/30/3_Hive/"
                                   title="Hive初识"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">Hive初识</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    






                
            </div>
        </div>

        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="copyright-info info-item">
        &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2024
        
            &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">Keep Team</a>
        
    </div>

    <div class="theme-info info-item">
        由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
    </div>

    

    

    
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="post-tools-list border-box">
        <!-- PC encrypt again -->
        

        <!-- PC TOC show toggle -->
        

        <!-- PC go comment -->
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <!-- toggle mode -->
        
            <li class="tools-item tool-toggle-theme-mode flex-center">
                <i class="fas fa-moon"></i>
            </li>
        

        <!-- rss -->
        

        <!-- to bottom -->
        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    

    <!-- tablet toc -->
    
</main>





<!-- common js -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local search -->


<!-- lazyload -->


<div class="">
    <!-- home page -->
    

    <!-- post page -->
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        

        <!-- copyright-info -->
        

        <!-- share -->
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->



</body>
</html>
